<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="Wilker Lucio">
<title>Pathom Developers Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Pathom Developers Guide</h1>
<div class="details">
<span id="author" class="author">Wilker Lucio</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">Jan 31, 2018</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_about_this_book">1.1. About this Book</a>
<ul class="sectlevel3">
<li><a href="#_work_in_progress">1.1.1. Work in Progress</a></li>
<li><a href="#_contributing">1.1.2. Contributing</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_getting_started">2. Getting Started</a>
<ul class="sectlevel2">
<li><a href="#_query_notation_introduction">2.1. Query Notation Introduction</a></li>
<li><a href="#_parsing_context">2.2. Parsing Context</a></li>
<li><a href="#_parsing_environment">2.3. Parsing Environment</a></li>
<li><a href="#_a_trivial_parser">2.4. A Trivial Parser</a></li>
<li><a href="#_a_parser_with_entity_lookups_and_computed_attributes">2.5. A Parser with Entity Lookups and Computed Attributes</a></li>
<li><a href="#_entity_lookups">2.6. Entity Lookups</a></li>
</ul>
</li>
<li><a href="#_pathom_core_engine">3. Pathom Core Engine</a>
<ul class="sectlevel2">
<li><a href="#_readers">3.1. Readers</a>
<ul class="sectlevel3">
<li><a href="#_functions_as_readers">3.1.1. Functions as Readers</a></li>
<li><a href="#map-dispatcher">3.1.2. Maps as Readers</a></li>
<li><a href="#vector-dispatcher">3.1.3. Vectors of Readers [aka composed readers]</a></li>
<li><a href="#_dynamic_readers">3.1.4. Dynamic Readers</a></li>
</ul>
</li>
<li><a href="#Entities">3.2. Entities</a>
<ul class="sectlevel3">
<li><a href="#_using_code_p_entity_code">3.2.1. Using <code>p/entity</code></a></li>
<li><a href="#_understanding_joins">3.2.2. Understanding Joins</a></li>
<li><a href="#_dependent_attributes">3.2.3. Dependent Attributes</a></li>
<li><a href="#atom-entities">3.2.4. Atom entities</a></li>
<li><a href="#_union_queries">3.2.5. Union queries</a></li>
</ul>
</li>
<li><a href="#_error_handling">3.3. Error handling</a>
<ul class="sectlevel3">
<li><a href="#_fail_fast">3.3.1. Fail fast</a></li>
<li><a href="#_raising_errors">3.3.2. Raising errors</a></li>
</ul>
</li>
<li><a href="#dispatch-helpers">3.4. Dispatch helpers</a></li>
<li><a href="#_mutations">3.5. Mutations</a></li>
<li><a href="#RequestCaching">3.6. Request Caching</a></li>
<li><a href="#_plugins">3.7. Plugins</a>
<ul class="sectlevel3">
<li><a href="#_shard_switch">3.7.1. Shard switch</a></li>
</ul>
</li>
<li><a href="#_testing_todo">3.8. Testing #TODO</a></li>
<li><a href="#_placeholders">3.9. Placeholders</a></li>
<li><a href="#_profiling">3.10. Profiling</a></li>
<li><a href="#_path_tracking">3.11. Path tracking</a></li>
<li><a href="#_async_parsing_todo">3.12. Async parsing #TODO</a></li>
</ul>
</li>
<li><a href="#_pathom_connect">4. Pathom Connect</a>
<ul class="sectlevel2">
<li><a href="#_using_connect">4.1. Using Connect</a>
<ul class="sectlevel3">
<li><a href="#_global_resolvers">4.1.1. Global resolvers</a></li>
<li><a href="#_resolvers_with_input">4.1.2. Resolvers with input</a></li>
<li><a href="#_multiple_inputs_todo">4.1.3. Multiple inputs #TODO</a></li>
<li><a href="#_single_input_requirements">4.1.4. Single input requirements</a></li>
<li><a href="#_connect_readers">4.1.5. Connect readers</a></li>
</ul>
</li>
<li><a href="#_understanding_the_indexes">4.2. Understanding the indexes</a>
<ul class="sectlevel3">
<li><a href="#_code_index_resolvers_code">4.2.1. <code>index-resolvers</code></a></li>
<li><a href="#_code_index_oir_code">4.2.2. <code>index-oir</code></a></li>
<li><a href="#_code_index_io_code">4.2.3. <code>index-io</code></a></li>
<li><a href="#connect-index-idents">4.2.4. <code>idents</code></a></li>
<li><a href="#_code_autocomplete_ignore_code">4.2.5. <code>autocomplete-ignore</code></a></li>
<li><a href="#_merging_indexes_todo">4.2.6. Merging indexes #TODO</a></li>
</ul>
</li>
<li><a href="#_auto_testing_todo">4.3. Auto testing #TODO</a></li>
<li><a href="#_exploration_with_oge_todo">4.4. Exploration with OgE #TODO</a></li>
</ul>
</li>
<li><a href="#_graphql_integration">5. GraphQL Integration</a>
<ul class="sectlevel2">
<li><a href="#_fulcro_network">5.1. Fulcro Network</a>
<ul class="sectlevel3">
<li><a href="#_pulling_data">5.1.1. Pulling data</a></li>
<li><a href="#_calling_mutations">5.1.2. Calling mutations</a></li>
<li><a href="#_custom_reads_future">5.1.3. Custom reads #future</a></li>
<li><a href="#_crud_example_todo">5.1.4. CRUD Example #TODO</a></li>
</ul>
</li>
<li><a href="#_connect_todo">5.2. Connect #TODO</a></li>
<li><a href="#edn_gql">5.3. EDN&#8594;GraphQL</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a><a class="link" href="#_introduction">1. Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>pathom</code> library provides a rich set of functionality to build robust parsers to
process Clojure queries using the Om.next query format (which is an extended version of
the Datomic pull syntax):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A reader abstraction that allows for easy composition.</p>
</li>
<li>
<p>The concept of <code>entity</code> which works as a base framework for reusable sharable readers.</p>
</li>
<li>
<p>A plugin system with some built-in plugins:</p>
<div class="ulist">
<ul>
<li>
<p>Error handler: Handles errors at an attribute level.</p>
</li>
<li>
<p>Request cache: For caching the results of parsing repetition that can happen on a single request.</p>
</li>
<li>
<p>Profiler: a plugin to measure the time spent on each attribute during the parser.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>Connect</code>: a higher level abstraction that can resolve attribute relationships automatically. For
example automatic traversal of database joins or resolving data through network requests.
This enables exploratory capabilities and much simpler access when the need arises to do
extra work to resolve a single conceptual join.</p>
</li>
<li>
<p>GraphQL integration: Use GraphQL endpoints directly from your query system (in development).</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_about_this_book"><a class="anchor" href="#_about_this_book"></a><a class="link" href="#_about_this_book">1.1. About this Book</a></h3>
<div class="sect3">
<h4 id="_work_in_progress"><a class="anchor" href="#_work_in_progress"></a><a class="link" href="#_work_in_progress">1.1.1. Work in Progress</a></h4>
<div class="paragraph">
<p>This is a work in progress. If you find an error, please submit a PR to fix it, or an issue with details of the problem.</p>
</div>
</div>
<div class="sect3">
<h4 id="_contributing"><a class="anchor" href="#_contributing"></a><a class="link" href="#_contributing">1.1.2. Contributing</a></h4>
<div class="paragraph">
<p>This source for this book is hosted on <a href="https://github.com/wilkerlucio/pathom-book">Github</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started"><a class="anchor" href="#_getting_started"></a><a class="link" href="#_getting_started">2. Getting Started</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this chapter we&#8217;ll give you some basics for using the library to parse arbitrary
Om Next-style queries. In order to understand this book you should understand the
syntax of these queries. More details about the overall notation can be found in
the Om Next documentation and in the <a href="http://book.fulcrologic.com/#_the_query_and_mutation_language">Fulcro Developer&#8217;s Guide</a></p>
</div>
<div class="paragraph">
<p>For now, you can get by with just a short introduction:</p>
</div>
<div class="sect2">
<h3 id="_query_notation_introduction"><a class="anchor" href="#_query_notation_introduction"></a><a class="link" href="#_query_notation_introduction">2.1. Query Notation Introduction</a></h3>
<div class="paragraph">
<p>We&#8217;re assuming you know something about Om Next&#8217;s query notation, but for introduction
purposes, here&#8217;s a short summary:</p>
</div>
<div class="paragraph">
<p>A query is a vector that lists the items you want. A keyword requests a scalar (opaque) value, and
a map indicates a to-many or to-one join (resolved at runtime using database content).</p>
</div>
<div class="paragraph">
<p>Queries are always "relative" to some starting context (which is typically supplied via parameters
or by a top-level join).</p>
</div>
<div class="paragraph">
<p>If you want to obtain the name and age of "some" person:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">:person/name</span> <span class="symbol">:person/age</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to obtain a person&#8217;s name and the street of their address you might write this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">:person/name</span> {<span class="symbol">:person/address</span> [<span class="symbol">:address/street</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>where we imagine that the underlying database has some kind of normalization that needs to be traversed in order to satisfy the address data.</p>
</div>
<div class="paragraph">
<p>The result of running a query is a map containing the result (in the same recursive shape as the query):</p>
</div>
<div class="paragraph">
<p>Running <code>[:person/name :person/age]</code> against the person "Sam" might give:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sam</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/age</span> <span class="integer">32</span>}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running <code>[:person/name {:person/address [:address/street]}]</code> against that same person might give:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sam</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/address</span> {<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">111 Main St.</span><span class="delimiter">&quot;</span></span>}}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_context"><a class="anchor" href="#_parsing_context"></a><a class="link" href="#_parsing_context">2.2. Parsing Context</a></h3>
<div class="paragraph">
<p>We mentioned earlier that our graph queries are relative. A query has no meaning until it is rooted (i.e. run
<strong>against</strong> a given context). You can&#8217;t ask for <code>:person/name</code> without knowing which entity (person) you&#8217;re asking it of.
Joins have this same property, but in the case of joins the context has already been resolved, because the parser
reached the target of the join by traversing a graph edge from root.</p>
</div>
<div class="paragraph">
<p>In our earlier example of running <code>[:person/name {:person/address [:address/street]}]</code> against "Sam", we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">:person/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sam</span><span class="delimiter">&quot;</span></span> <span class="symbol">:person/address</span> {<span class="symbol">:address/street</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">111 Main St.</span><span class="delimiter">&quot;</span></span>}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but how did it know what to run the subquery <code>[:address/street]</code> against? It used&#8217;s Sam&#8217;s address, of course!</p>
</div>
<div class="paragraph">
<p>So, at any given point when parsing a query, there is always a <strong>context</strong>. For our purposes the entity (or entities if to-many) that you&#8217;ve reached by processing the query so far.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_environment"><a class="anchor" href="#_parsing_environment"></a><a class="link" href="#_parsing_environment">2.3. Parsing Environment</a></h3>
<div class="paragraph">
<p>When parsing you supply the initial environment which also establishes the context of the query. The environment is a map that can contain anything you wish, and can be seen in any code that you plug in to process the query. There are some predefined (namespaced) keys that have special meaning to the parser. In particular <code>:com.wsscode.pathom.core/reader</code> can be used to supply a reader function for the parser to use.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_trivial_parser"><a class="anchor" href="#_a_trivial_parser"></a><a class="link" href="#_a_trivial_parser">2.4. A Trivial Parser</a></h3>
<div class="paragraph">
<p>Our first example will be for a very simple parser that can resolve a single scalar property using
a function that you define:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.hello-pathom</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

<span class="comment">; Our first reader, defined with a map whose keys are the dispatch key from the query,</span>
<span class="comment">; and whose value is a function to resolve the data to return.</span>
(<span class="keyword">def</span> <span class="function">computed</span>
  <span class="comment">; here we define that for the dispatch-key :hello we are going to return &quot;World&quot;</span>
  {<span class="symbol">:hello</span> (<span class="keyword">fn</span> [env] <span class="string"><span class="delimiter">&quot;</span><span class="content">World</span><span class="delimiter">&quot;</span></span>)})

<span class="comment">; Create a parser</span>
(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {}))

<span class="comment">; Run the parser, using the reader, against a simple query (arguments are env and query):</span>
(parser {<span class="symbol">::p/reader</span> computed} [<span class="symbol">:hello</span>])
<span class="comment">; =&gt; {:hello &quot;World&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Before we continue, I would like to talk to about some patterns on the graph parsing game, it will give you a better
understanding of how/why this library is designed the way it is. When parsing a graph API like this, there are 3 major
types of reading that you want to do at any level, let&#8217;s talk about those:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Entity attributes</strong>: Attributes that are present on the current entity (node) that is being processed during the parser (the current context). For example, if we are at a <code>customer</code> node, it might have attributes like <code>:customer/id</code> and <code>:customer/name</code>. When the query asks for those we should fetch them from the entity itself.</p>
</li>
<li>
<p><strong>Computed attributes</strong>: If the desired key is <strong>not</strong> literally present as data on the entity of the current context then we can try to compute it from one (or many) other readers, those readers are usually maps (closed sets of attributes) or multimethods (open sets of attributes), and they can be configured to handle the keys by doing some process/computation. There are 2 categories of these:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><strong>Globals</strong>: if the computed attribute <strong>doesn&#8217;t</strong> depend on any data from the entity in the current context then it is a global computation and can be used independent of the current context.</p>
</li>
<li>
<p><strong>Derived attributes</strong>: when the computed attribute depends on some property of the current entity, then we call it a derivation. Derivations are often relationship mappings, like navigating a join on <code>:customer/address</code> or <code>:customer/friends</code>. They may also be a transformation of real data from the contextual entity.</p>
</li>
</ol>
</div>
</li>
<li>
<p><strong>Entity lookups</strong>: This is the om.next default way to look for a specific entity on the graph using the ident syntax (eg: <code>[:customer/id 123]</code>). Using such a literal entity lookup is a way of setting the context. It is essentially a "goto entity" for graph notation.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We will cover examples of all of these in this chapter. More recent versions of pathom include <code>Connect</code>.
It&#8217;s a new approach to define a mechanism for <strong>Computed attributes</strong> that we will talk about later.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
You should take great care to use unique names for your graph query attributes. The contextual behavior can lead to confusion very quickly, and it is made worse if you&#8217;re not sure which part of your query is even running. Also, software evolution will almost certainly lead you to use your queries with new APIs, and you will want to avoid naming collisions. Use qualified (ideally namespaced) keywords.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_a_parser_with_entity_lookups_and_computed_attributes"><a class="anchor" href="#_a_parser_with_entity_lookups_and_computed_attributes"></a><a class="link" href="#_a_parser_with_entity_lookups_and_computed_attributes">2.5. A Parser with Entity Lookups and Computed Attributes</a></h3>
<div class="paragraph">
<p>Next, let&#8217;s show an example of using entity and computed attributes together.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s talk about the parsing environment a little more. Typically the parsing environment will include potentially dynamic things (e.g. a database connection) and some consistent things (e.g. the reader).</p>
</div>
<div class="paragraph">
<p>In the prior example we explicitly added the reader to the environment every time we called the parser. In cases where there are specific things that you&#8217;d always like included in the environment we can instead use the plugin system to pre-set them.</p>
</div>
<div class="paragraph">
<p>In our prior example we had:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and every call to the parser needed an explicit reader: <code>(parser {::p/reader computed} [:hello])</code></p>
</div>
<div class="paragraph">
<p>A vector of plugins can be added when the parser is created. The <code>p/env-plugin</code> automatically adds the given map of data to the parsing environment every time the resulting parser is called.</p>
</div>
<div class="paragraph">
<p>Our example can be converted to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed]})]}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and now each call to the parser needs nothing in the supplied env: <code>(parser {} [:hello])</code>.</p>
</div>
<div class="paragraph">
<p>The example below sets up a more complex scenario where we&#8217;ll want to pass a database in the environment on every call (it might change over time). Placing our reader logic in the env plugin will make this a little cleaner.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a quick summary of the things we&#8217;ll be using for quick reference:</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><code>p/join</code></dt>
<dd>
<p>Satisfy a to-one join, and continue parsing.</p>
</dd>
<dt><code>p/join-seq</code></dt>
<dd>
<p>Satisfy a to-many join, and continue parsing</p>
</dd>
<dt><code>p/entity-attr!</code></dt>
<dd>
<p>Look up a (required) attribute from the current entity (context). Throws if missing.</p>
</dd>
<dt><code>p/map-reader</code></dt>
<dd>
<p>A reader that assumes the current contextual entity is a map, and tries to use it to satisfy queries</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.hello-entities</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

<span class="comment">; define some data of tv shows, as a simple map-based table</span>
(<span class="keyword">def</span> <span class="function">tv-shows</span>
  {<span class="symbol">:rm</span>  <span class="error">#</span><span class="symbol">:tv-show</span>{<span class="symbol">:title</span>         <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick and Morty</span><span class="delimiter">&quot;</span></span>
                  <span class="symbol">:character-ids</span> [<span class="symbol">:rick</span> <span class="symbol">:summer</span> <span class="symbol">:morty</span>]}
   <span class="symbol">:bcs</span> <span class="error">#</span><span class="symbol">:tv-show</span>{<span class="symbol">:title</span>         <span class="string"><span class="delimiter">&quot;</span><span class="content">Better Call Saul</span><span class="delimiter">&quot;</span></span>
                  <span class="symbol">:character-ids</span> [<span class="symbol">:bcs</span>]}
   <span class="symbol">:got</span> <span class="error">#</span><span class="symbol">:tv-show</span>{<span class="symbol">:title</span>         <span class="string"><span class="delimiter">&quot;</span><span class="content">Game of Thrones</span><span class="delimiter">&quot;</span></span>
                  <span class="symbol">:character-ids</span> [<span class="symbol">:arya</span> <span class="symbol">:ygritte</span>]}})

<span class="comment">; TV show characters, &quot;joined&quot; to tv-shows by &quot;tv-show-id&quot;</span>
(<span class="keyword">def</span> <span class="function">characters</span>
  {<span class="symbol">:rick</span>    <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick Sanshes</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:rm</span>}
   <span class="symbol">:summer</span>  <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Summer Smith</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:rm</span>}
   <span class="symbol">:saul</span>    <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Saul Goodman</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:bcs</span>}
   <span class="symbol">:arya</span>    <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Arya Stark</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:got</span>}
   <span class="symbol">:morty</span>   <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Morty Smith</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:rm</span>}
   <span class="symbol">:ygritte</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Ygritte</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:got</span>}})

<span class="comment">; Helper functions are always handy when parsing.</span>
<span class="comment">; In this case we only need the db from our parsing environment,</span>
<span class="comment">; but taking env as a parameter makes calling it easier and enables</span>
<span class="comment">; evolution of env without intrusive API changes.</span>
(<span class="keyword">defn</span> <span class="function">characters-by-ids</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Return a list of charaters for the given character IDs from the current parsing env</span><span class="delimiter">&quot;</span></span>
  [{<span class="symbol">::keys</span> [db] <span class="symbol">:as</span> env} ids]
  (<span class="keyword">map</span> (<span class="keyword">get</span> @db <span class="symbol">:characters</span>) ids))

(<span class="keyword">def</span> <span class="function">computed</span>
  <span class="comment">; example of a &quot;global attribute&quot;: returns a random character from our</span>
  <span class="comment">; database, and can be fetched without regard for context.</span>
  {<span class="symbol">:characters/random</span>
   <span class="comment">; pretend the db is your datomic database or a Postgres connection,</span>
   <span class="comment">; anything that would enable you to reach the data</span>
   (<span class="keyword">fn</span> [{<span class="symbol">::keys</span> [db] <span class="symbol">:as</span> env}]
     (<span class="keyword">let</span> [character (rand-nth (<span class="keyword">-&gt;</span> @db <span class="symbol">:characters</span> <span class="keyword">vals</span> <span class="keyword">vec</span>))]
       <span class="comment">; Use `join` to recursively parse the sub-query with the new to-one entity context</span>
       (p/join character env)))

   <span class="comment">; another &quot;globally accessible&quot; bit of data that can be queried (independent of context)</span>
   <span class="comment">; and returns a to-many result of some pre-chosen &quot;leaing role&quot; characters.</span>
   <span class="symbol">:characters/main</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; Process to-many joins with join-seq using a sequence as the new context:</span>
     (p/join-seq env (characters-by-ids env [<span class="symbol">:rick</span> <span class="symbol">:morty</span> <span class="symbol">:saul</span> <span class="symbol">:arya</span>])))

   <span class="comment">; an example of a more complex computed relashionship:</span>
   <span class="comment">; extract the tv-show according to the :character/tv-show-id</span>
   <span class="comment">; on a character entity (current context)</span>
   <span class="symbol">:character/tv-show</span>
   (<span class="keyword">fn</span> [{<span class="symbol">::keys</span> [db] <span class="symbol">:as</span> env}]
     <span class="comment">; the p/entity-attr! will try to get the :character/tv-show from current entity</span>
     <span class="comment">; if it's not there it will make a query for it using the same parser. If</span>
     <span class="comment">; it can't be got it will trigger an exception with the issue details, making</span>
     <span class="comment">; easier to identify the problem</span>
     (<span class="keyword">let</span> [tv-show-id (p/entity-attr! env <span class="symbol">:character/tv-show-id</span>)]
       (p/join (some-&gt; @db <span class="symbol">:tv-shows</span> (<span class="keyword">get</span> tv-show-id)) env)))

   <span class="comment">; example of making a computed property, get the number of characters</span>
   <span class="comment">; (the current context must be a tv-show)</span>
   <span class="symbol">:tv-show/characters-count</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; just give a count on members, and again, will raise exception if</span>
     <span class="comment">; :tv-show/character-ids fails to be reached</span>
     (<span class="keyword">count</span> (p/entity-attr! env <span class="symbol">:tv-show/character-ids</span>)))})

(<span class="keyword">def</span> <span class="function">parser</span>
  <span class="comment">; This time we are using the env-plugin to initialize the environment, this is good</span>
  <span class="comment">; to set the defaults for your parser to be called. Also, we are attaching the built-in</span>
  <span class="comment">; reader map-reader on the game, so it will read the keys from the entity map. Check</span>
  <span class="comment">; Entity page on wiki for more information.</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader computed]})]}))

<span class="comment">; call the parser, create and send our atom database</span>
(parser {<span class="symbol">::db</span> (<span class="keyword">atom</span> {<span class="symbol">:characters</span> characters
                     <span class="symbol">:tv-shows</span>   tv-shows})}
        [{<span class="symbol">:characters/main</span> [<span class="symbol">:character/name</span> {<span class="symbol">:character/tv-show</span> [<span class="symbol">:tv-show/title</span>
                                                                 <span class="symbol">:tv-show/characters-count</span>]}]}
         <span class="comment">; feeling lucky today?</span>
         {<span class="symbol">:characters/random</span> [<span class="symbol">:character/name</span>]}])
<span class="comment">; =&gt;</span>
<span class="comment">; #:characters{:main   [#:character{:name &quot;Rick Sanshes&quot;, :tv-show #:tv-show{:name &quot;Rick and Morty&quot;, :characters-count 3}}</span>
<span class="comment">;                       #:character{:name &quot;Morty Smith&quot;, :tv-show #:tv-show{:name &quot;Rick and Morty&quot;, :characters-count 3}}</span>
<span class="comment">;                       #:character{:name &quot;Saul Goodman&quot;, :tv-show #:tv-show{:name &quot;Better Call Saul&quot;, :characters-count 1}}</span>
<span class="comment">;                       #:character{:name &quot;Arya Stark&quot;, :tv-show #:tv-show{:name &quot;Game of Thrones&quot;, :characters-count 2}}],</span>
<span class="comment">;              :random #:character{:name &quot;Saul Goodman&quot;}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>map-reader</code> is responsible for reading the values on the contextual <strong>entity attributes</strong>. When a value is not found then the next reader in the chain is asked: the <code>computed</code> reader kicks in trying to compute the value. If no reader is able to respond a value of <code>::p/not-found</code> will be returned.</p>
</div>
</div>
<div class="sect2">
<h3 id="_entity_lookups"><a class="anchor" href="#_entity_lookups"></a><a class="link" href="#_entity_lookups">2.6. Entity Lookups</a></h3>
<div class="paragraph">
<p>Entity lookups are done by <strong>ident</strong> (as defined by Om Next and Fulcro). An <strong>ident</strong> is simply a vector whose first element is a keyword and second element is any value. The first element is thought of as the "table" or "kind" of thing, and the second as the ID of a specific one. For example <code>[:character/id :rick]</code> is an ident that "conceptually points to" the entity of type/table "character/id" with ID ":rick".</p>
</div>
<div class="paragraph">
<p>You typically add support for entity lookups using a multimethod that dispatches on the first element of an ident. The predefined value <code>::p/continue</code> can be used by an entity lookup reader to indicate that it should ask the next reader to try to resolve the lookup.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll be using one additional new function:</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><code>p/ident-value</code></dt>
<dd>
<p>Given the env, it will return the ID portion of the ident that is being resolved (current context).</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The code below can be added to the prior example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">; databases and other prior code</span>
<span class="keyword">..</span><span class="keyword">.</span>

<span class="comment">;;;;;; Handle Entity Lookups ;;;;;;;</span>

(<span class="keyword">defmulti</span> <span class="function">entity</span> p/entity-dispatch)

<span class="comment">; default case returns ::p/continue to sign to pathom that</span>
<span class="comment">; this reader can't handle the given entry</span>
(<span class="keyword">defmethod</span> <span class="function">entity</span> <span class="symbol">:default</span> [_] <span class="symbol">::p/continue</span>)

(<span class="keyword">defmethod</span> <span class="function">entity</span> <span class="symbol">:character/id</span> [{<span class="symbol">::keys</span> [db] <span class="symbol">:as</span> env}]
  <span class="comment">; from the key [:character/id :rick], p/ident-value will return :rick</span>
  (<span class="keyword">let</span> [id (p/ident-value env)]
    <span class="comment">; same thing as would find a record by id on your database</span>
    <span class="comment">; we return ::p/continue to signal this reader wans't able to</span>
    <span class="comment">; fetch it entity, so the parser can try the next one, more about this</span>
    <span class="comment">; on Readers with page</span>
    (p/join (<span class="keyword">get-in</span> @db [<span class="symbol">:characters</span> id] <span class="symbol">::p/continue</span>) env)))

<span class="comment">; same thing for tv shows</span>
(<span class="keyword">defmethod</span> <span class="function">entity</span> <span class="symbol">:tv-show/id</span> [{<span class="symbol">::keys</span> [db] <span class="symbol">:as</span> env}]
  (<span class="keyword">let</span> [id (p/ident-value env)]
    (p/join (<span class="keyword">get-in</span> @db [<span class="symbol">:tv-shows</span> id] <span class="symbol">::p/continue</span>) env)))

(<span class="keyword">def</span> <span class="function">parser</span>
  <span class="comment">; add our entity reader to our reader list</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader
                                                     computed
                                                     entity]})]}))

<span class="comment">; testing our new queries</span>
(parser {<span class="symbol">::db</span> (<span class="keyword">atom</span> {<span class="symbol">:characters</span> characters
                     <span class="symbol">:tv-shows</span>   tv-shows})}
        [[<span class="symbol">:character/id</span> <span class="symbol">:arya</span>] <span class="comment">; query for the entire entity</span>
         {[<span class="symbol">:tv-show/id</span> <span class="symbol">:rm</span>] <span class="comment">; use the given tv show as the &quot;context&quot; for the join</span>
          [<span class="symbol">:tv-show/title</span>
           {<span class="symbol">:tv-show/characters</span> [<span class="symbol">:character/name</span>]}]}])
<span class="comment">; =&gt;</span>
<span class="comment">; {[:character/id :arya] #:character{:name &quot;Arya Stark&quot;, :tv-show-id :got}</span>
<span class="comment">;  [:tv-show/id :rm]     #:tv-show{:title      &quot;Rick and Morty&quot;</span>
<span class="comment">;                                  :characters [#:character{:name &quot;Rick Sanshes&quot;}</span>
<span class="comment">;                                               #:character{:name &quot;Summer Smith&quot;}</span>
<span class="comment">;                                               #:character{:name &quot;Morty Smith&quot;}]}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These building blocks enable quite a bit of query processing. As your graph grows larger it will make sense to use some additional tools to help split your parser into different pieces. In particular <code>computed</code> can be written with a dispatch mechanism instead of being represented as a map. See the section about
<a href="#dispatch-helpers">dispatch helpers</a> for more information.</p>
</div>
<div class="paragraph">
<p>Here is the complete code for the example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.hello-entities</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">tv-shows</span>
  {<span class="symbol">:rm</span>  <span class="error">#</span><span class="symbol">:tv-show</span>{<span class="symbol">:title</span>         <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick and Morty</span><span class="delimiter">&quot;</span></span>
                  <span class="symbol">:character-ids</span> [<span class="symbol">:rick</span> <span class="symbol">:summer</span> <span class="symbol">:morty</span>]}
   <span class="symbol">:bcs</span> <span class="error">#</span><span class="symbol">:tv-show</span>{<span class="symbol">:title</span>         <span class="string"><span class="delimiter">&quot;</span><span class="content">Better Call Saul</span><span class="delimiter">&quot;</span></span>
                  <span class="symbol">:character-ids</span> [<span class="symbol">:bcs</span>]}
   <span class="symbol">:got</span> <span class="error">#</span><span class="symbol">:tv-show</span>{<span class="symbol">:title</span>         <span class="string"><span class="delimiter">&quot;</span><span class="content">Game of Thrones</span><span class="delimiter">&quot;</span></span>
                  <span class="symbol">:character-ids</span> [<span class="symbol">:arya</span> <span class="symbol">:ygritte</span>]}})

(<span class="keyword">def</span> <span class="function">characters</span>
  {<span class="symbol">:rick</span>    <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick Sanshes</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:rm</span>}
   <span class="symbol">:summer</span>  <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Summer Smith</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:rm</span>}
   <span class="symbol">:saul</span>    <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Saul Goodman</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:bcs</span>}
   <span class="symbol">:arya</span>    <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Arya Stark</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:got</span>}
   <span class="symbol">:morty</span>   <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Morty Smith</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:rm</span>}
   <span class="symbol">:ygritte</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Ygritte</span><span class="delimiter">&quot;</span></span> <span class="symbol">:tv-show-id</span> <span class="symbol">:got</span>}})

(<span class="keyword">defn</span> <span class="function">characters-by-ids</span> [{<span class="symbol">::keys</span> [db]} ids]
  (<span class="keyword">map</span> (<span class="keyword">get</span> @db <span class="symbol">:characters</span>) ids))

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:characters/random</span>
   (<span class="keyword">fn</span> [{<span class="symbol">::keys</span> [db] <span class="symbol">:as</span> env}]
     <span class="comment">; take a hand of the entity we want to be the current node</span>
     (<span class="keyword">let</span> [character (rand-nth (<span class="keyword">-&gt;</span> @db <span class="symbol">:characters</span> <span class="keyword">vals</span> <span class="keyword">vec</span>))]
       <span class="comment">; to parse the sub-query with the entity we use the join function</span>
       (p/join character env)))

   <span class="symbol">:characters/main</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; since we decided to get the env in the characters-by-ids the argument</span>
     <span class="comment">; passing is a brease</span>
     (p/join-seq env (characters-by-ids env [<span class="symbol">:rick</span> <span class="symbol">:morty</span> <span class="symbol">:saul</span> <span class="symbol">:arya</span>])))

   <span class="symbol">:character/tv-show</span>
   (<span class="keyword">fn</span> [{<span class="symbol">::keys</span> [db] <span class="symbol">:as</span> env}]
     (<span class="keyword">let</span> [tv-show-id (p/entity-attr! env <span class="symbol">:character/tv-show-id</span>)]
       (p/join (some-&gt; @db <span class="symbol">:tv-shows</span> (<span class="keyword">get</span> tv-show-id)) env)))

   <span class="symbol">:tv-show/characters</span>
   (<span class="keyword">fn</span> [env]
     (<span class="keyword">let</span> [ids (p/entity-attr! env <span class="symbol">:tv-show/character-ids</span>)]
       (p/join-seq env (characters-by-ids env ids))))

   <span class="symbol">:tv-show/characters-count</span>
   (<span class="keyword">fn</span> [env]
     (<span class="keyword">count</span> (p/entity-attr! env <span class="symbol">:tv-show/character-ids</span>)))})

(<span class="keyword">defmulti</span> <span class="function">entity</span> p/entity-dispatch)

(<span class="keyword">defmethod</span> <span class="function">entity</span> <span class="symbol">:default</span> [_] <span class="symbol">::p/continue</span>)

(<span class="keyword">defmethod</span> <span class="function">entity</span> <span class="symbol">:character/id</span> [{<span class="symbol">::keys</span> [db] <span class="symbol">:as</span> env}]
  (<span class="keyword">let</span> [id (p/ident-value env)]
    (p/join (<span class="keyword">get-in</span> @db [<span class="symbol">:characters</span> id] <span class="symbol">::p/continue</span>) env)))

(<span class="keyword">defmethod</span> <span class="function">entity</span> <span class="symbol">:tv-show/id</span> [{<span class="symbol">::keys</span> [db] <span class="symbol">:as</span> env}]
  (<span class="keyword">let</span> [id (p/ident-value env)]
    (p/join (<span class="keyword">get-in</span> @db [<span class="symbol">:tv-shows</span> id] <span class="symbol">::p/continue</span>) env)))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader
                                                     computed
                                                     entity]})]}))

(parser {<span class="symbol">::db</span> (<span class="keyword">atom</span> {<span class="symbol">:characters</span> characters
                     <span class="symbol">:tv-shows</span>   tv-shows})}
        [[<span class="symbol">:character/id</span> <span class="symbol">:arya</span>]
         {[<span class="symbol">:tv-show/id</span> <span class="symbol">:rm</span>]
          [<span class="symbol">:tv-show/title</span>
           {<span class="symbol">:tv-show/characters</span> [<span class="symbol">:character/name</span>]}]}])
<span class="comment">; =&gt;</span>
<span class="comment">; {[:character/id :arya] #:character{:name &quot;Arya Stark&quot;, :tv-show-id :got}</span>
<span class="comment">;  [:tv-show/id :rm]     #:tv-show{:title      &quot;Rick and Morty&quot;</span>
<span class="comment">;                                  :characters [#:character{:name &quot;Rick Sanshes&quot;}</span>
<span class="comment">;                                               #:character{:name &quot;Summer Smith&quot;}</span>
<span class="comment">;                                               #:character{:name &quot;Morty Smith&quot;}]}}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pathom_core_engine"><a class="anchor" href="#_pathom_core_engine"></a><a class="link" href="#_pathom_core_engine">3. Pathom Core Engine</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_readers"><a class="anchor" href="#_readers"></a><a class="link" href="#_readers">3.1. Readers</a></h3>
<div class="paragraph">
<p>A reader is a function that will process a single entry from the query. For example, given the following query:
<code>[:name :age]</code>. If you ask an <code>om.next</code> parser to read this the reader function will be called twice; once for <code>:name</code> and another one for <code>:age</code>. Note that in the case of joins, the parser will only be called for the join entry, but not for it&#8217;s children (not automatically), for example: given the query <code>[:name :age {:parent [:name :gender]}]</code>. The reader function will be called 3 times now, one for <code>:name</code>, one for <code>:age</code> and one for <code>:parent</code>, when reading <code>:parent</code>, your reader code is responsible for checking that it has a children query, and do a recursive call (or anything else you want to do to handle this join). During this documentation, we are going to see many ways to implement those readers.</p>
</div>
<div class="paragraph">
<p>Please note the following differences between <code>om.next</code> readers and <code>pathom</code> readers: In <code>om.next</code> a parse read functions has the following signature: <code>(fn [env dispatch-key params])</code>. In <code>pathom</code> we use a smaller version instead, which is: <code>(fn [env])</code>. The <code>env</code> already contains the <code>dispatch-key</code> and <code>params</code>, so there is no loss of information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">get-in</span> env [<span class="symbol">:ast</span> <span class="symbol">:dispatch-key</span>]) <span class="comment">; =&gt; dispatch-key</span>
(<span class="keyword">get-in</span> env [<span class="symbol">:ast</span> <span class="symbol">:params</span>]) <span class="comment">; =&gt; params</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, in <code>om.next</code> you need to return the value wrapped in <code>{:value "your-content"}</code>. In <code>pathom</code> this wrapping is done automatically for you: just return the final value.</p>
</div>
<div class="paragraph">
<p>Readers can be 1-arity function, maps, or vectors. See <a href="#map-dispatcher">Map dispatcher</a> and <a href="#vector-dispatcher">Vector dispacher</a> for information on those respectively.</p>
</div>
<div class="paragraph">
<p>Here is a formal Clojure Spec definiton for a <code>pathom</code> reader:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(s/def <span class="symbol">::reader-map</span> (s/map-of <span class="keyword">keyword?</span> <span class="symbol">::reader</span>))
(s/def <span class="symbol">::reader-seq</span> (s/coll-of <span class="symbol">::reader</span> <span class="symbol">:kind</span> <span class="keyword">vector?</span>))
(s/def <span class="symbol">::reader-fn</span> (s/fspec <span class="symbol">:args</span> (s/cat <span class="symbol">:env</span> <span class="symbol">::env</span>)
                            <span class="symbol">:ret</span> any?))

(s/def <span class="symbol">::reader</span>
  (s/or <span class="symbol">:fn</span> <span class="symbol">::reader-fn</span>
        <span class="symbol">:map</span> <span class="symbol">::reader-map</span>
        <span class="symbol">:list</span> <span class="symbol">::reader-seq</span>))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_functions_as_readers"><a class="anchor" href="#_functions_as_readers"></a><a class="link" href="#_functions_as_readers">3.1.1. Functions as Readers</a></h4>
<div class="paragraph">
<p>These are quite simply a function that receive the env and resolve the read. More than one reader can exist in a chain, and the special return value <code>::p/continue</code> allows a reader to indicate it cannot resolve the given property (to continue processing the chain). Returning any value (including <code>nil</code>) you&#8217;ve resolved the property to that value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.fn-dispatch</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">defn</span> <span class="function">read-value</span> [{<span class="symbol">:keys</span> [ast]}]
  (<span class="keyword">let</span> [<span class="keyword">key</span> (<span class="keyword">get</span> ast <span class="symbol">:dispatch-key</span>)]
    (<span class="keyword">case</span> <span class="keyword">key</span>
      <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Saul</span><span class="delimiter">&quot;</span></span>
      <span class="symbol">:family</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Goodman</span><span class="delimiter">&quot;</span></span>
      <span class="comment">; good pratice: return ::p/continue when your reader is unable</span>
      <span class="comment">; to handle the request</span>
      <span class="symbol">::p/continue</span>)))

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> read-value})]}))

(parser {} [<span class="symbol">:name</span> <span class="symbol">:family</span>])
<span class="comment">; =&gt; {:name &quot;Saul&quot; :family &quot;Goodman&quot;}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="map-dispatcher"><a class="anchor" href="#map-dispatcher"></a><a class="link" href="#map-dispatcher">3.1.2. Maps as Readers</a></h4>
<div class="paragraph">
<p>Since it is very common to want to resolve queries from a fixed set of possibilities we support defining a map as a reader. This is really just a "dispatch table" to functions that will receive <code>env</code>.  We can re-write the previous example as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.reader-map-dispatch</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">user-reader</span>
  {<span class="symbol">:name</span>   (<span class="keyword">fn</span> [_] <span class="string"><span class="delimiter">&quot;</span><span class="content">Saul</span><span class="delimiter">&quot;</span></span>)
   <span class="symbol">:family</span> (<span class="keyword">fn</span> [_] <span class="string"><span class="delimiter">&quot;</span><span class="content">Goodman</span><span class="delimiter">&quot;</span></span>)})

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> user-reader})]}))

(parser {} [<span class="symbol">:name</span> <span class="symbol">:family</span>])
<span class="comment">; =&gt; {:name &quot;Saul&quot; :family &quot;Goodman&quot;}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The built-in Map Reader will return <code>::p/continue</code> if the map it is looking in does not contain the key for the attribute being resolved. This allows it to be safely used in a vector of readers.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="vector-dispatcher"><a class="anchor" href="#vector-dispatcher"></a><a class="link" href="#vector-dispatcher">3.1.3. Vectors of Readers [aka composed readers]</a></h4>
<div class="paragraph">
<p>Using a vector for a reader is how you define a chain of readers. This allows you to define readers that serve a particular purpose. For example, some library author might want to supply readers to compose into your parser, or you might have different modules of database-specific readers that you&#8217;d like to keep separate.</p>
</div>
<div class="paragraph">
<p>When pathom is trying to resolve a given attribute (say <code>:person/name</code>) in some context (say against the "Sam" entity) it will start at the beginning of the reader chain. The first reader will be asked to resolve the attribute.   If the reader can handle the value then it will be returned and no other readers will be consulted.  If it instead returns the special value <code>::p/continue</code> it is signalling that it could not resolve it (map readers do this if the attribute key is not in their map).  When this happens the next reader in the chain will be tried.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.reader-vector-dispatch</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

<span class="comment">; a map dispatcher for the :name key</span>
(<span class="keyword">def</span> <span class="function">name-reader</span>
  {<span class="symbol">:name</span>   (<span class="keyword">fn</span> [_] <span class="string"><span class="delimiter">&quot;</span><span class="content">Saul</span><span class="delimiter">&quot;</span></span>)})

<span class="comment">; a map dispatcher for the :family key</span>
(<span class="keyword">def</span> <span class="function">family-reader</span>
  {<span class="symbol">:family</span> (<span class="keyword">fn</span> [_] <span class="string"><span class="delimiter">&quot;</span><span class="content">Goodman</span><span class="delimiter">&quot;</span></span>)})

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [name-reader family-reader]})]}))

(parser {} [<span class="symbol">:name</span> <span class="symbol">:family</span> <span class="symbol">:other</span>])
<span class="comment">; =&gt; {:name &quot;Saul&quot;, :family &quot;Goodman&quot;, :other :com.wsscode.pathom.core/not-found}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If no reader in the chain returns a value (all readers reeturn <code>::p/continue</code>), then <code>::p/not-found</code> will be returned.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
When you write your readers you should always remember to return <code>::p/continue</code> when you can&#8217;t handle a given key. This way your reader will play nice in composition scenarios.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_dynamic_readers"><a class="anchor" href="#_dynamic_readers"></a><a class="link" href="#_dynamic_readers">3.1.4. Dynamic Readers</a></h4>
<div class="paragraph">
<p>Recursive calls are widespread during parsing, and Om.next makes it even easier by providing the current parser as part of the environment. The problem is that if you just call the same parser recursively then there is no chance to change how the reading <strong>process</strong> operates.</p>
</div>
<div class="paragraph">
<p>In order to improve this situation <code>pathom</code> makes the <code>:parser</code> <strong>and</strong> <code>r:eader</code> part of the environment, allowing you to <strong>replace</strong> it when doing a recursive parser call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-dynamic-reader</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">defn</span> <span class="function">user-reader</span> [{<span class="symbol">:keys</span> [ast]}]
  (<span class="keyword">let</span> [<span class="keyword">key</span> (<span class="keyword">get</span> ast <span class="symbol">:dispatch-key</span>)]
    (<span class="keyword">case</span> <span class="keyword">key</span>
      <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Saul</span><span class="delimiter">&quot;</span></span>
      <span class="symbol">:family</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Goodman</span><span class="delimiter">&quot;</span></span>)))

(<span class="keyword">defn</span> <span class="function">root-reader</span> [{<span class="symbol">:keys</span> [ast query parser] <span class="symbol">:as</span> env}]
  (<span class="keyword">let</span> [<span class="keyword">key</span> (<span class="keyword">get</span> ast <span class="symbol">:dispatch-key</span>)]
    (<span class="keyword">case</span> <span class="keyword">key</span>
      <span class="symbol">:current-user</span> (parser (<span class="keyword">assoc</span> env <span class="symbol">::p/reader</span> user-reader) query))))

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> root-reader})]}))

(parser {} [{<span class="symbol">:current-user</span> [<span class="symbol">:name</span> <span class="symbol">:family</span>]}])
<span class="comment">; =&gt; {:current-user {:name &quot;Saul&quot; :family &quot;Goodman&quot;}}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Replacing the reader when parsing is rarely needed in practice. The functional dispatch and vector of readers cover most common cases; however, replacing the reader could be useful in a scenario such as code splitting where the readers were not all available at the time of initial parser construction.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Entities"><a class="anchor" href="#Entities"></a><a class="link" href="#Entities">3.2. Entities</a></h3>
<div class="paragraph">
<p>An entity to <code>pathom</code> is the graph node that is tracked as the current context, and from which information (attributes and graph edges to other entities) can be derived.  The current entity needs to be "map-like": It should work with all normal map-related functions like <code>get</code>, <code>contains?</code>, etc.</p>
</div>
<div class="paragraph">
<p>As Pathom parses the query it tracks the current entity in the environment at key <code>::p/entity</code>. This makes it easier to write more reusable and flexible readers as we&#8217;ll see later.</p>
</div>
<div class="sect3">
<h4 id="_using_code_p_entity_code"><a class="anchor" href="#_using_code_p_entity_code"></a><a class="link" href="#_using_code_p_entity_code">3.2.1. Using <code>p/entity</code></a></h4>
<div class="paragraph">
<p>The <code>p/entity</code> function exists as a convenience for pulling the current entity from the parsing environment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom-docs.using-entity</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">defn</span> <span class="function">read-attr</span> [env]
  (<span class="keyword">let</span> [e (p/entity env)
        k (<span class="keyword">get-in</span> env [<span class="symbol">:ast</span> <span class="symbol">:dispatch-key</span>])]
    (<span class="keyword">if</span> (<span class="keyword">contains?</span> e k)
      (<span class="keyword">get</span> e k)
      <span class="symbol">::p/continue</span>)))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [read-attr]})]}))

<span class="comment">; we send the entity using ::p/entity key on environment</span>
(parser {<span class="symbol">::p/entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">60</span>}} [<span class="symbol">:character/name</span> <span class="symbol">:character/age</span> <span class="symbol">:character/foobar</span>])
<span class="comment">; =&gt; #:character{:name &quot;Rick&quot;, :age 60, :foobar :com.wsscode.pathom.core/not-found}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the code above is a partial implementation of the <a href="#MapReader">map-dispatcher</a>.</p>
</div>
<div class="paragraph">
<p>The <code>map-reader</code> just has the additional ability to understand how to walk a map that has a tree shape that already "fits" our query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom-docs.using-entity-map-reader</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> p/map-reader})]}))

<span class="comment">; we send the entity using ::p/entity key on environment</span>
(parser {<span class="symbol">::p/entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">60</span>
                                <span class="symbol">:family</span> [<span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Morty</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">14</span>}
                                         <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Summer</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">17</span>}]
                                <span class="symbol">:first-episode</span> <span class="error">#</span><span class="symbol">:episode</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Pilot</span><span class="delimiter">&quot;</span></span> <span class="symbol">:season</span> <span class="integer">1</span> <span class="symbol">:number</span> <span class="integer">1</span>}}}
        [<span class="symbol">:character/name</span> <span class="symbol">:character/age</span>
         {<span class="symbol">:character/family</span> [<span class="symbol">:character/age</span>]}
         {<span class="symbol">:character/first-episode</span> [<span class="symbol">:episode/name</span> <span class="symbol">:episode/number</span>]}])
<span class="comment">; =&gt;</span>
<span class="comment">; #:character{:name &quot;Rick&quot;,</span>
<span class="comment">;             :age 60,</span>
<span class="comment">;             :family [#:character{:age 14} #:character{:age 17}],</span>
<span class="comment">;             :first-episode #:episode{:name &quot;Pilot&quot;, :number 1}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that you understand where the entity context is tracked I encourage you to check the <code>p/map-reader</code> implementation. It&#8217;s not very long and will give you a better understanding of all of the concepts covered so far.</p>
</div>
</div>
<div class="sect3">
<h4 id="_understanding_joins"><a class="anchor" href="#_understanding_joins"></a><a class="link" href="#_understanding_joins">3.2.2. Understanding Joins</a></h4>
<div class="paragraph">
<p>The other significant task when processing a graph query is walking a graph edge to another entity (or entities) when we find a join.</p>
</div>
<div class="paragraph">
<p>The subquery for a join is in the <code>:query</code> of the environment. Essentially it is a recursive step where we run the parser on the subquery while replacing the "current entity":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">join</span> [entity {<span class="symbol">:keys</span> [parser query] <span class="symbol">:as</span> env}]
  (parser (<span class="keyword">assoc</span> env <span class="symbol">::p/entity</span> entity) query))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The real pathom implementation handles some additional scenarios: like the <strong>empty sub-query</strong> case (it returns the full entity), the special <code>*</code> query (so you can combine the whole entity + extra computed attributes), and union queries.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>p/join</code> to "invent" a relation that can then be queried:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom-docs.using-entity-map-reader</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">rick</span>
  <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span>          <span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span>
              <span class="symbol">:age</span>           <span class="integer">60</span>
              <span class="symbol">:family</span>        [<span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Morty</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">14</span>}
                              <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Summer</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">17</span>}]
              <span class="symbol">:first-episode</span> <span class="error">#</span><span class="symbol">:episode</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Pilot</span><span class="delimiter">&quot;</span></span> <span class="symbol">:season</span> <span class="integer">1</span> <span class="symbol">:number</span> <span class="integer">1</span>}})

(<span class="keyword">def</span> <span class="function">char-name-&gt;voice</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">Relational information representing edges from character names to actors</span><span class="delimiter">&quot;</span></span>
  {<span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span>   <span class="error">#</span><span class="symbol">:actor</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Justin Roiland</span><span class="delimiter">&quot;</span></span> <span class="symbol">:nationality</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">US</span><span class="delimiter">&quot;</span></span>}
   <span class="string"><span class="delimiter">&quot;</span><span class="content">Morty</span><span class="delimiter">&quot;</span></span>  <span class="error">#</span><span class="symbol">:actor</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Justin Roiland</span><span class="delimiter">&quot;</span></span> <span class="symbol">:nationality</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">US</span><span class="delimiter">&quot;</span></span>}
   <span class="string"><span class="delimiter">&quot;</span><span class="content">Summer</span><span class="delimiter">&quot;</span></span> <span class="error">#</span><span class="symbol">:actor</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Spencer Grammer</span><span class="delimiter">&quot;</span></span> <span class="symbol">:nationality</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">US</span><span class="delimiter">&quot;</span></span>}})

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:character/voice</span> <span class="comment">; support an invented join attribute</span>
   (<span class="keyword">fn</span> [env]
     (<span class="keyword">let</span> [{<span class="symbol">:character/keys</span> [<span class="keyword">name</span>]} (p/entity env)
           voice (<span class="keyword">get</span> char-name-&gt;voice <span class="keyword">name</span>)]
       (p/join voice env)))})

(<span class="keyword">def</span> <span class="function">parser</span>
  <span class="comment">; process with map-reader first, then try with computed</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader computed]})]}))

(parser {<span class="symbol">::p/entity</span> rick} <span class="comment">; start with rick (as current entity)</span>
        '[<span class="symbol">:character/name</span>
          {<span class="symbol">:character/voice</span> [<span class="symbol">:actor/name</span>]}
          {<span class="symbol">:character/family</span> [<span class="keyword">*</span> <span class="symbol">:character/voice</span>]}])</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are three different scenarios demonstrated in the above query:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Using the invented join property in a normal join. This allows for a subquery that constrains the data returned (from the actor in this case).</p>
</li>
<li>
<p>Using the <code>*</code> in a query, which returns all "known" attributes of the "current contextual" entity.</p>
</li>
<li>
<p>Using an additional (non-joined) <code>:character/voice</code> with <code>*</code> "adds in" that additional information. When a property is queried for that is processed via <code>p/join</code> then the entire entity will be returned even though there is no subquery.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_dependent_attributes"><a class="anchor" href="#_dependent_attributes"></a><a class="link" href="#_dependent_attributes">3.2.3. Dependent Attributes</a></h4>
<div class="paragraph">
<p>When computing attributes it is possible that you might need some other attribute for the current context that is <strong>also</strong> computed. You could hard-code a solution, but that would create all sorts of static code problems that could be difficult to manage as your code evolves: changes to the readers, for example, could easily break it and lead to difficult bugs.</p>
</div>
<div class="paragraph">
<p>Instead, it is important that readers be able to resolve attributes they need from the "current context" in an abstract manner (i.e. the same way that they query itself is being resolved). The <code>p/entity</code> function has an additional arity for handling this exact case. You pass it a list of attributes that should be "made available" on the current entity, and it will use the parser to ensure that they are there (if possible):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [e (p/entity env [<span class="symbol">:x</span>])]
   <span class="comment">; e now has :x on it if possible, even if it is computed elsewhere</span>
   <span class="keyword">..</span><span class="keyword">.</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows this in context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.entity-attribute-dependency</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:greet</span>
   (<span class="keyword">fn</span> [env]
     (<span class="keyword">let</span> [{<span class="symbol">:character/keys</span> [<span class="keyword">name</span>]} (p/entity env)]
       (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>)))

   <span class="symbol">:invite</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; requires the computed property `:greet`, which might not have been computed into the current context yet.</span>
     (<span class="keyword">let</span> [{<span class="symbol">:keys</span> [greet]} (p/entity env [<span class="symbol">:greet</span>])]
       (<span class="keyword">str</span> greet <span class="string"><span class="delimiter">&quot;</span><span class="content"> Come to visit us in Neverland!</span><span class="delimiter">&quot;</span></span>)))})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader
                                                     computed]})]}))

(parser {<span class="symbol">::p/entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary</span><span class="delimiter">&quot;</span></span>}}
        [<span class="symbol">:invite</span>])
<span class="comment">; =&gt; {:invite &quot;Hello Mary! Come to visit us in Neverland!&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a variant <code>p/entity!</code> that raises an error if your desired attributes are not found. It&#8217;s recommended to use the enforced version if you need the given attributes, as it will give your user a better error message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.entity-attribute-enforce</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:greet</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; enfore the character/name to be present, otherwise raises error, try removing</span>
     <span class="comment">; the attribute from the entity and see what happens</span>
     (<span class="keyword">let</span> [<span class="keyword">name</span> (p/entity-attr! env <span class="symbol">:character/name</span>)]
       (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello </span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>)))

   <span class="symbol">:invite</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; now we are enforcing the attribute to be available, otherwise raise an error</span>
     <span class="comment">; try changing the :greet to :greete and run the file, you will see the error</span>
     (<span class="keyword">let</span> [greet (p/entity-attr! env <span class="symbol">:greet</span>)]
       (<span class="keyword">str</span> greet <span class="string"><span class="delimiter">&quot;</span><span class="content"> Come to visit us in Neverland!</span><span class="delimiter">&quot;</span></span>)))})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader
                                                     computed]})]}))

(parser {<span class="symbol">::p/entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary</span><span class="delimiter">&quot;</span></span>}}
        [<span class="symbol">:invite</span>])
<span class="comment">; =&gt; {:invite &quot;Hello Mary! Come to visit us in Neverland!&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the parse fails on an enforced attribute you will get an exception. For example, if the current entity were <code>#:character{:nam "Mary"}</code> we&#8217;d see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">CompilerException clojure.lang.ExceptionInfo<span class="error">:</span> Entity attributes #{<span class="symbol">:character/name</span>} could <span class="keyword">not</span> be realized <span class="error">#</span><span class="symbol">:com.wsscode.pathom.core</span>{<span class="symbol">:entity</span> <span class="error">#</span><span class="symbol">:character</span>{<span class="symbol">:nam</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary</span><span class="delimiter">&quot;</span></span>}, <span class="symbol">:path</span> [<span class="symbol">:invite</span> <span class="symbol">:greet</span>], <span class="symbol">:missing-attributes</span> #{<span class="symbol">:character/name</span>}}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If computed attributes require IO or intense computation you should consider adding caching to improve parsing performance. Remember that a given query might traverse the same node more than once! Imagine a query that asks for your friends and co-workers. When there is this kind of overlap the same computational code may run more than once. See <a href="#RequestCaching">Request Caching</a> for more details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="atom-entities"><a class="anchor" href="#atom-entities"></a><a class="link" href="#atom-entities">3.2.4. Atom entities</a></h4>
<div class="paragraph">
<p>As you move from node to node, you can choose to wrap the new contextual entity in an atom. This can be used as a narrow kind of caching mechanism that allows for a reader to add information into the current entity as it computes it, but which is valid for only
the processing of the current entity (is lost as soon as the next join is followed). Therefore, this won&#8217;t help with the overhead of re-visiting the same entity more than once when processing different parts of the same query.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The built-in function <code>p/entity</code> always returns a Clojure map, if the entity is an atom it will deref it automatically.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example using an entity atom:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.entities.atom-entities</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {}))

(<span class="keyword">def</span> <span class="function">sample-item</span>
  {<span class="symbol">:id</span> <span class="integer">42</span>
   <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Some Product</span><span class="delimiter">&quot;</span></span>
   <span class="symbol">:description</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">This should be a cool product.</span><span class="delimiter">&quot;</span></span>})

(<span class="keyword">defn</span> <span class="function">item-reader</span> [{<span class="symbol">:keys</span> [ast] <span class="symbol">:as</span> env}]
  <span class="error">#</span>?(<span class="symbol">:clj</span> (Thread/sleep <span class="integer">1000</span>))
  (<span class="keyword">-&gt;</span> (p/swap-entity! env <span class="keyword">merge</span> sample-item)
      (<span class="keyword">get</span> (<span class="symbol">:key</span> ast))))

(<span class="keyword">comment</span>
  (<span class="keyword">time</span>
    (parser {<span class="symbol">::p/entity</span> (<span class="keyword">atom</span> {})
             <span class="symbol">::p/reader</span> {<span class="symbol">:id</span> item-reader <span class="symbol">:name</span> item-reader <span class="symbol">:description</span> item-reader}}
      [<span class="symbol">:id</span> <span class="symbol">:name</span> <span class="symbol">:description</span>]))
  <span class="comment">; since we are always hitting the expensive reader, each entry has to spend a second</span>

  <span class="comment">; &quot;Elapsed time: 3013.386195 msecs&quot;</span>
  <span class="comment">; =&gt; {:id 42, :name &quot;Some Product&quot;, :description &quot;This should be a cool product.&quot;}</span>

  (<span class="keyword">time</span>
    (parser {<span class="symbol">::p/entity</span> (<span class="keyword">atom</span> {})
             <span class="symbol">::p/reader</span> [p/map-reader
                         {<span class="symbol">:id</span> item-reader <span class="symbol">:name</span> item-reader <span class="symbol">:description</span> item-reader}]}
      [<span class="symbol">:id</span> <span class="symbol">:name</span> <span class="symbol">:description</span>]))
  <span class="comment">; now, adding the map-reader to the game will allow it to check on the entity first,</span>
  <span class="comment">; making the cached entity effective.</span>

  <span class="comment">;&quot;Elapsed time: 1006.479409 msecs&quot;</span>
  <span class="comment">;=&gt; {:id 42, :name &quot;Some Product&quot;, :description &quot;This should be a cool product.&quot;}</span>
  )</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_union_queries"><a class="anchor" href="#_union_queries"></a><a class="link" href="#_union_queries">3.2.5. Union queries</a></h4>
<div class="paragraph">
<p>Union queries allow us to handle edges that lead to heterogeneous nodes. For example a to-many relation for media that could result in a book or movie. Following such an edge requires that we have a different <strong>subquery</strong> depending on what we <strong>actually</strong> find in the database.</p>
</div>
<div class="paragraph">
<p>Here is an example where we want to use a query that will search to find a user, a movie or a book:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.entity-union</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">search-results</span>
  [{<span class="symbol">:type</span> <span class="symbol">:user</span>
    <span class="symbol">:user/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Jack Sparrow</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">:type</span> <span class="symbol">:movie</span>
    <span class="symbol">:movie/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Ted</span><span class="delimiter">&quot;</span></span>
    <span class="symbol">:movie/year</span> <span class="integer">2012</span>}
   {<span class="symbol">:type</span> <span class="symbol">:book</span>
    <span class="symbol">:book/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">The Joy of Clojure</span><span class="delimiter">&quot;</span></span>}])

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader]})]}))

(parser {<span class="symbol">::p/entity</span> {<span class="symbol">:search</span> search-results}
         <span class="comment">; here we set where pathom should look on the entity to determine the union path</span>
         <span class="symbol">::p/union-path</span> <span class="symbol">:type</span>}
        [{<span class="symbol">:search</span> {<span class="symbol">:user</span> [<span class="symbol">:user/name</span>]
                   <span class="symbol">:movie</span> [<span class="symbol">:movie/title</span>]
                   <span class="symbol">:book</span> [<span class="symbol">:book/title</span>]}}])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, unions need to have a way to determine which path to go based on the entity at hand. In the example above we used the <code>:type</code> (a key on the entity) to determine which branch to follow.
The value of <code>::p/union-path</code> can be a keyword (from something inside entity or a computed attribute) or a function (that takes <code>env</code> and returns the correct key (e.g. <code>:book</code>) to use for the union query).</p>
</div>
<div class="paragraph">
<p>If you want <code>::p/union-path</code> to be more contextual you can of course set it in the <code>env</code> during the join process, as in the next example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.entity-union-contextual</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">search-results</span>
  [{<span class="symbol">:type</span> <span class="symbol">:user</span>
    <span class="symbol">:user/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Jack Sparrow</span><span class="delimiter">&quot;</span></span>}
   {<span class="symbol">:type</span> <span class="symbol">:movie</span>
    <span class="symbol">:movie/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Ted</span><span class="delimiter">&quot;</span></span>
    <span class="symbol">:movie/year</span> <span class="integer">2012</span>}
   {<span class="symbol">:type</span> <span class="symbol">:book</span>
    <span class="symbol">:book/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">The Joy of Clojure</span><span class="delimiter">&quot;</span></span>}])

(<span class="keyword">def</span> <span class="function">search</span>
  {<span class="symbol">:search</span>
   (<span class="keyword">fn</span> [env]
     <span class="comment">; join-seq is the same as join, but for sequences, note we set the ::p/union-path</span>
     <span class="comment">; here. This is more common since the *method* of determining type will vary for</span>
     <span class="comment">; different queries and data.</span>
     (p/join-seq (<span class="keyword">assoc</span> env <span class="symbol">::p/union-path</span> <span class="symbol">:type</span>) search-results))})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [search
                                                     p/map-reader]})]}))

(parser {}
        [{<span class="symbol">:search</span> {<span class="symbol">:user</span> [<span class="symbol">:user/name</span>]
                   <span class="symbol">:movie</span> [<span class="symbol">:movie/title</span>]
                   <span class="symbol">:book</span> [<span class="symbol">:book/title</span>]}}])</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is something beautiful about having an immutable environment; you can make changes with confidence that it will not affect indirect points of the parsing process.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_error_handling"><a class="anchor" href="#_error_handling"></a><a class="link" href="#_error_handling">3.3. Error handling</a></h3>
<div class="paragraph">
<p>By default, pathom parser will stop if some exception occurs during the parsing process. This is often undesirable if some node fails you still can return the other ones that succeed. You can use the <code>error-handler-plugin</code>. This plugin will wrap each read call with a try-catch block, and in case an error occurs, a value of <code>::p/reader-error</code> will be placed in that node, while details of it will go in a separate tree, but at the same path. Better an example to demonstrate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.error-handling</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">computed</span>
  <span class="comment">; create a handle key that will trigger an error when called</span>
  {<span class="symbol">:trigger-error</span>
   (<span class="keyword">fn</span> [_]
     (<span class="keyword">throw</span> (ex-info <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span> {<span class="symbol">:foo</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>})))})

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed flow-reader]})
                          <span class="comment">; add the error handler plugin</span>
                          p/error-handler-plugin]}))

(parser {} [{<span class="symbol">:go</span> [<span class="symbol">:key</span> {<span class="symbol">:nest</span> [<span class="symbol">:trigger-error</span> <span class="symbol">:other</span>]}
                  <span class="symbol">:trigger-error</span>]}])
<span class="comment">; =&gt;</span>
<span class="comment">; {:go {:key :leaf</span>
<span class="comment">;       :nest {:trigger-error :com.wsscode.pathom.core/reader-error</span>
<span class="comment">;              :other :leaf}</span>
<span class="comment">;       :trigger-error :com.wsscode.pathom.core/reader-error}</span>
<span class="comment">;  :com.wsscode.pathom.core/errors {[:go :nest :trigger-error] &quot;class clojure.lang.ExceptionInfo: Error triggered - {:foo \&quot;bar\&quot;}&quot;</span>
<span class="comment">;                                   [:go :trigger-error] &quot;class clojure.lang.ExceptionInfo: Error triggered - {:foo \&quot;bar\&quot;}&quot;}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, when an error occurs, the key <code>::p/errors</code> will be added to the returned map, containing the detailed error message indexed by the error path. You can customize how the error is exported in this map by setting the key <code>::p/process-error</code> in your environment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.error-handling-process</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">computed</span>
  <span class="comment">; create a handle key that will trigger an error when called</span>
  {<span class="symbol">:trigger-error</span>
   (<span class="keyword">fn</span> [_]
     (<span class="keyword">throw</span> (ex-info <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span> {<span class="symbol">:foo</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>})))})

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

<span class="comment">; our error processing function</span>
(<span class="keyword">defn</span> <span class="function">process-error</span> [env err]
  <span class="comment">; if you use some error reporting service, this is a good place</span>
  <span class="comment">; to trigger a call to then, here you have the error and the full</span>
  <span class="comment">; environment of when it ocurred, so you might want to some extra</span>
  <span class="comment">; information like the query and the current path on it so you can</span>
  <span class="comment">; replay it for debugging</span>

  <span class="comment">; we are going to simply return the error message from the error</span>
  <span class="comment">; if you want to return the same thing as the default, use the</span>
  <span class="comment">; function (p/error-str err)</span>
  (<span class="keyword">.</span>getMessage err))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed flow-reader]
                                         <span class="comment">; add the error processing to the environment</span>
                                         <span class="symbol">::p/process-error</span> process-error})
                          <span class="comment">; add the error handler plugin</span>
                          p/error-handler-plugin]}))

(parser {} [{<span class="symbol">:go</span> [<span class="symbol">:key</span> {<span class="symbol">:nest</span> [<span class="symbol">:trigger-error</span> <span class="symbol">:other</span>]}
                  <span class="symbol">:trigger-error</span>]}])
<span class="comment">; =&gt;</span>
<span class="comment">; {:go {:key :leaf</span>
<span class="comment">;       :nest {:trigger-error :com.wsscode.pathom.core/reader-error</span>
<span class="comment">;              :other :leaf}</span>
<span class="comment">;       :trigger-error :com.wsscode.pathom.core/reader-error}</span>
<span class="comment">;  :com.wsscode.pathom.core/errors {[:go :nest :trigger-error] &quot;Error triggered&quot;</span>
<span class="comment">;                                   [:go :trigger-error]       &quot;Error triggered&quot;}}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_fail_fast"><a class="anchor" href="#_fail_fast"></a><a class="link" href="#_fail_fast">3.3.1. Fail fast</a></h4>
<div class="paragraph">
<p>Having each node being caught is great for the UI, but not so much for testing. During testing you probably prefer the parser to blow up as fast as possible so you don&#8217;t accumulate a bunch of errors that get impossible to read. Having to create a different parser to remove the <code>error-handler-plugin</code> can be annoying, so there is an option to solve that. Send the key <code>::p/fail-fast?</code> as true in the environment, and the try/catch will not be done, making it fail as soon as an exception fires, for example, using our previous parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(parser {<span class="symbol">::p/fail-fast?</span> <span class="predefined-constant">true</span>}
        [{<span class="symbol">:go</span> [<span class="symbol">:key</span> {<span class="symbol">:nest</span> [<span class="symbol">:trigger-error</span> <span class="symbol">:other</span>]}
               <span class="symbol">:trigger-error</span>]}])
<span class="comment">; =&gt; CompilerException clojure.lang.ExceptionInfo: Error triggered {:foo &quot;bar&quot;}, ...</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_raising_errors"><a class="anchor" href="#_raising_errors"></a><a class="link" href="#_raising_errors">3.3.2. Raising errors</a></h4>
<div class="paragraph">
<p>The default error output format (in a separated tree) is very convenient for direct API
calls, because they leave a clean output on the data part. But if you want to expose those
errors on the UI, pulling then out of the separated tree can be a bit of a pain. To help
with that there is a <code>p/raise-errors</code> helper, this will lift the errors so they are present
at the same level of the error entry. Let&#8217;s take our last error output example and process
it with <code>p/raise-errors</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(p/raise-errors {<span class="symbol">:go</span> {<span class="symbol">:key</span> <span class="symbol">:leaf</span>
                      <span class="symbol">:nest</span> {<span class="symbol">:trigger-error</span> <span class="symbol">:com.wsscode.pathom.core/reader-error</span>
                             <span class="symbol">:other</span> <span class="symbol">:leaf</span>}
                      <span class="symbol">:trigger-error</span> <span class="symbol">:com.wsscode.pathom.core/reader-error</span>}
                 <span class="symbol">:com.wsscode.pathom.core/errors</span> {[<span class="symbol">:go</span> <span class="symbol">:nest</span> <span class="symbol">:trigger-error</span>] <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span>
                                                  [<span class="symbol">:go</span> <span class="symbol">:trigger-error</span>] <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span>}})

<span class="comment">; outputs:</span>

{<span class="symbol">:go</span> {<span class="symbol">:key</span> <span class="symbol">:leaf</span>
      <span class="symbol">:nest</span> {<span class="symbol">:trigger-error</span> <span class="symbol">:com.wsscode.pathom.core/reader-error</span>
             <span class="symbol">:other</span> <span class="symbol">:leaf</span>
             <span class="symbol">:com.wsscode.pathom.core/errors</span> {<span class="symbol">:trigger-error</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span>}}
      <span class="symbol">:trigger-error</span> <span class="symbol">:com.wsscode.pathom.core/reader-error</span>
      <span class="symbol">:com.wsscode.pathom.core/errors</span> {<span class="symbol">:trigger-error</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Error triggered</span><span class="delimiter">&quot;</span></span>}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that we don&#8217;t have the root <code>::p/errors</code> anymore, instead it is placed at the
same level of the error attribute. So the path <code>[::p/errors [:go :nest :trigger-error]]</code>
turns into <code>[:go :nest ::p/errors :trigger-error]</code>. This makes very easy to pull the
error on the client-side.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dispatch-helpers"><a class="anchor" href="#dispatch-helpers"></a><a class="link" href="#dispatch-helpers">3.4. Dispatch helpers</a></h3>
<div class="paragraph">
<p>Using multi-methods is a good way to make open readers, <code>pathom</code> provides helpers for two common dispatch strategies:
<code>key-dispatch</code> and <code>entity-dispatch</code>. Here is a pattern that I often use on parsers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.dispatch-helpers</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">cities</span>
  {<span class="string"><span class="delimiter">&quot;</span><span class="content">Recife</span><span class="delimiter">&quot;</span></span>    {<span class="symbol">:city/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Recife</span><span class="delimiter">&quot;</span></span> <span class="symbol">:city/country</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Brazil</span><span class="delimiter">&quot;</span></span>}
   <span class="string"><span class="delimiter">&quot;</span><span class="content">São Paulo</span><span class="delimiter">&quot;</span></span> {<span class="symbol">:city/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">São Paulo</span><span class="delimiter">&quot;</span></span> <span class="symbol">:city/country</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Brazil</span><span class="delimiter">&quot;</span></span>}})

(<span class="keyword">def</span> <span class="function">city-&gt;neighbors</span>
  {<span class="string"><span class="delimiter">&quot;</span><span class="content">Recife</span><span class="delimiter">&quot;</span></span> [{<span class="symbol">:neighbor/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Boa Viagem</span><span class="delimiter">&quot;</span></span>}
             {<span class="symbol">:neighbor/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Piedade</span><span class="delimiter">&quot;</span></span>}
             {<span class="symbol">:neighbor/name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Casa Amarela</span><span class="delimiter">&quot;</span></span>}]})

<span class="comment">; this will dispatch according to the ast dispatch-key</span>
(<span class="keyword">defmulti</span> <span class="function">computed</span> p/key-dispatch)

<span class="comment">; use virtual attributes to handle data not present on the maps, like computed attributes, relationships, and globals</span>
(<span class="keyword">defmethod</span> <span class="function">computed</span> <span class="symbol">:city/neighbors</span> [env]
  (<span class="keyword">let</span> [<span class="keyword">name</span> (p/entity-attr! env <span class="symbol">:city/name</span>)]
    (p/join-seq env (city-&gt;neighbors <span class="keyword">name</span>))))

<span class="comment">; an example of global, same as before but without any dependency on the entity</span>
(<span class="keyword">defmethod</span> <span class="function">computed</span> <span class="symbol">:city/all</span> [env]
  (p/join-seq env (<span class="keyword">vals</span> cities)))

<span class="comment">; remember to return ::p/continue by default so non-handled cases can flow</span>
(<span class="keyword">defmethod</span> <span class="function">computed</span> <span class="symbol">:default</span> [_] <span class="symbol">::p/continue</span>)

<span class="comment">; just to make easy to re-use, our base entity reader consists of a map reader + virtual attributes</span>
(<span class="keyword">def</span> <span class="function">entity-reader</span> [p/map-reader computed])

<span class="comment">; dispatch for entity keys, eg: [:user/by-id 123]</span>
(<span class="keyword">defmulti</span> <span class="function">entity-lookup</span> p/entity-dispatch)

(<span class="keyword">defmethod</span> <span class="function">entity-lookup</span> <span class="symbol">:city/by-name</span> [env]
  <span class="comment">; the ident-value helper extracts the value part from the ident, as &quot;Recife&quot; in [:city/by-name &quot;Recife&quot;]</span>
  (<span class="keyword">let</span> [city (<span class="keyword">get</span> cities (p/ident-value env))]
    (p/join city env)))

(<span class="keyword">defmethod</span> <span class="function">entity-lookup</span> <span class="symbol">:default</span> [_] <span class="symbol">::p/continue</span>)

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader computed entity-lookup]})]}))

(parser {} [{<span class="symbol">:city/all</span> [<span class="symbol">:city/name</span>]}
            {[<span class="symbol">:city/by-name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Recife</span><span class="delimiter">&quot;</span></span>] [<span class="symbol">:city/neighbors</span>]}])
<span class="comment">; =&gt;</span>
<span class="comment">;{:city/all [#:city{:name &quot;Recife&quot;} #:city{:name &quot;São Paulo&quot;}]</span>
<span class="comment">; [:city/by-name &quot;Recife&quot;] #:city{:neighbors [#:neighbor{:name &quot;Boa Viagem&quot;}</span>
<span class="comment">;                                             #:neighbor{:name &quot;Piedade&quot;}</span>
<span class="comment">;                                             #:neighbor{:name &quot;Casa Amarela&quot;}]}}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mutations"><a class="anchor" href="#_mutations"></a><a class="link" href="#_mutations">3.5. Mutations</a></h3>
<div class="paragraph">
<p>To handle mutations, you can send the <code>:mutate</code> param to the parser.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.mutation</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [fulcro.client.primitives <span class="symbol">:as</span> fp]))

(<span class="keyword">defmulti</span> <span class="function">my-mutate</span> fp/dispatch)

(<span class="keyword">defmethod</span> <span class="function">my-mutate</span> `do-operation [{<span class="symbol">:keys</span> [state]} _ params]
  (<span class="keyword">swap!</span> state update <span class="symbol">:history</span> <span class="keyword">conj</span> {<span class="symbol">:op</span> <span class="symbol">:operation</span> <span class="symbol">:params</span> params}))

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">:mutate</span> my-mutate}))

(<span class="keyword">comment</span>
  (<span class="keyword">let</span> [state (<span class="keyword">atom</span> {<span class="symbol">:history</span> []})]
    (parser {<span class="symbol">:state</span> state} [`(do-operation {<span class="symbol">:foo</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>})
                            `(do-operation {<span class="symbol">:buz</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span>})])
    @state)
  <span class="comment">; =&gt; {:history [{:op :operation, :params {:foo &quot;bar&quot;}}</span>
  <span class="comment">;               {:op :operation, :params {:buz &quot;baz&quot;}}]}</span>
  )</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="RequestCaching"><a class="anchor" href="#RequestCaching"></a><a class="link" href="#RequestCaching">3.6. Request Caching</a></h3>
<div class="paragraph">
<p>As your queries grow, there are more and more optimizations that you can do avoid unnecessary IO or heavy computations. Here we are going to talk about a <code>request cache</code>, which is a fancy name for an atom that is initialized on every query and stays on the environment so you can share the cache across nodes. Let&#8217;s see how we can use that to speed up our query processing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.request-cache</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">defn</span> <span class="function">my-expensive-operation</span> [env]
  <span class="comment">; the cache key can be anything; if we were had an extra</span>
  <span class="comment">; variable here, like some id, a good cache key would be</span>
  <span class="comment">; like: [::my-expensive-operation id]</span>
  (p/cached env <span class="symbol">:my-key</span>
    <span class="comment">; we are going to send an atom with an int so that we can count</span>
    <span class="comment">; how many times this was called</span>
    (<span class="keyword">let</span> [counter (<span class="symbol">:counter</span> env)]
      <span class="comment">; a secondary sign if cache is working, let's make a delay</span>
      (Thread/sleep <span class="integer">1000</span>)
      <span class="comment">; increment and return</span>
      (<span class="keyword">swap!</span> counter <span class="keyword">inc</span>))))

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:cached</span> my-expensive-operation})

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed
                                                     flow-reader]})
                          <span class="comment">; add the request cache plugin for cache initialization</span>
                          p/request-cache-plugin]}))

(<span class="keyword">time</span>
  (parser {<span class="symbol">:counter</span> (<span class="keyword">atom</span> <span class="integer">0</span>)}
          [<span class="symbol">:x</span> <span class="symbol">:y</span> <span class="symbol">:cached</span>
           {<span class="symbol">:z</span> [<span class="symbol">:foo</span> {<span class="symbol">:bar</span> [<span class="symbol">:cached</span>]} <span class="symbol">:cached</span>]}]))
<span class="comment">; &quot;Elapsed time: 1006.760165 msecs&quot;</span>
<span class="comment">; =&gt;</span>
<span class="comment">; {:x      :leaf</span>
<span class="comment">;  :y      :leaf</span>
<span class="comment">;  :cached 1</span>
<span class="comment">;  :z      {:foo    :leaf</span>
<span class="comment">;           :bar    {:cached 1}</span>
<span class="comment">;           :cached 1}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember this cache is <strong>per request</strong>, so after a full query gets finished, the atom is discarded. If you want to make a cache that&#8217;s more durable (that retains information across requests), check the [[Plugins|Plugins]] documentation for more information on how to do that.</p>
</div>
</div>
<div class="sect2">
<h3 id="_plugins"><a class="anchor" href="#_plugins"></a><a class="link" href="#_plugins">3.7. Plugins</a></h3>
<div class="paragraph">
<p>Since <code>1.0.0-beta-8</code>, pathom included a plugin support. Plugins set code that wraps some of pathom operations, a plugin is a map where you bind keys from event names to functions. They work on <code>wrap</code> fashion, kind like <code>ring</code> wrappers. Here is what a plugin looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.plugin-example</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">my-plugin</span>
  <span class="comment">; the ::p/wrap-parser entry point wraps the entire parser,</span>
  <span class="comment">; this means it wraps the operation that runs once on each</span>
  <span class="comment">; query that runs with the parser</span>
  {<span class="symbol">::p/wrap-parser</span>
   (<span class="keyword">fn</span> [parser]
     <span class="comment">; here you can initialize stuff that runs only once per</span>
     <span class="comment">; parser, like a durable cache across requests</span>
     (<span class="keyword">fn</span> [env tx]
       <span class="comment">; here you could initialize per-request items, things</span>
       <span class="comment">; that needs to be set up once per query as we do on</span>
       <span class="comment">; request cache, or the error atom to accumulate errors</span>

       <span class="comment">; in this case, we are doing nothing, just calling the</span>
       <span class="comment">; previous parser, a pass-through wrapper if you may</span>
       (parser env tx)))

   <span class="comment">; this wraps the read function, meaning it will run once for</span>
   <span class="comment">; each recursive parser call that happens during your query</span>
   <span class="symbol">::p/wrap-read</span>
   (<span class="keyword">fn</span> [reader]
     (<span class="keyword">fn</span> [env]
       <span class="comment">; here you can wrap the parse read, in pathom we use this</span>
       <span class="comment">; on the error handler to do the try/catch per node, also</span>
       <span class="comment">; the profiler use this point to calculate the time spent</span>
       <span class="comment">; on a given node</span>

       <span class="comment">; this is also a good point to inject custom read keys if</span>
       <span class="comment">; you need to, the profile plugin, for example, can capture</span>
       <span class="comment">; the key ::p.profile/profile and export the current profile</span>
       <span class="comment">; information</span>
       (reader env)))})</code></pre>
</div>
</div>
<div class="paragraph">
<p>The plugin engine replaces the old <code>process-reader</code> in a much more powerful way. If you want to check a real example look for the source for the built-in plugins, they are quite small and yet powerful tools (grep for <code>-plugin</code> on the repository to find all of them).</p>
</div>
<div class="sect3">
<h4 id="_shard_switch"><a class="anchor" href="#_shard_switch"></a><a class="link" href="#_shard_switch">3.7.1. Shard switch</a></h4>
<div class="paragraph">
<p>For a more practical example, let&#8217;s say we are routing in a micro-service architecture
and our parser needs to be shard-aware. Let&#8217;s write a plugin that anytime it sees a <code>:shard</code>
param on a query; and it will update the <code>:shard</code> attribute on the environment and send
it down, providing that shard information for any node downstream.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.plugin-shard</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

(<span class="keyword">def</span> <span class="function">shard-reader</span>
  <span class="comment">; Clojure neat tricks, let's just fetch the shard</span>
  <span class="comment">; from the environment when :current-shard is asked</span>
  {<span class="symbol">:current-shard</span> <span class="symbol">:shard</span>})

(<span class="keyword">def</span> <span class="function">shard-plugin</span>
  {<span class="symbol">::p/wrap-read</span>
   (<span class="keyword">fn</span> [reader]
     (<span class="keyword">fn</span> [env]
       <span class="comment">; try to get a new shard from the query params</span>
       (<span class="keyword">let</span> [new-shard (<span class="keyword">get-in</span> env [<span class="symbol">:ast</span> <span class="symbol">:params</span> <span class="symbol">:shard</span>])]
         (reader (cond-&gt; env new-shard (<span class="keyword">assoc</span> <span class="symbol">:shard</span> new-shard))))))})

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [shard-reader flow-reader]})
                          <span class="comment">; use our shard plugin</span>
                          shard-plugin]}))

(parser {<span class="symbol">:shard</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">global</span><span class="delimiter">&quot;</span></span>}
        '[<span class="symbol">:a</span> <span class="symbol">:b</span> <span class="symbol">:current-shard</span>
          {(<span class="symbol">:go-s1</span> {<span class="symbol">:shard</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">s1</span><span class="delimiter">&quot;</span></span>})
           <span class="comment">; notice it flows down</span>
           [<span class="symbol">:x</span> <span class="symbol">:current-shard</span> {<span class="symbol">:y</span> [<span class="symbol">:current-shard</span>]}]}
          <span class="symbol">:c</span>
          {(<span class="symbol">:go-s2</span> {<span class="symbol">:shard</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">s2</span><span class="delimiter">&quot;</span></span>})
           [<span class="symbol">:current-shard</span>
            <span class="comment">; we can override at any point</span>
            {(<span class="symbol">:now-s3</span> {<span class="symbol">:shard</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">s3</span><span class="delimiter">&quot;</span></span>})
             [<span class="symbol">:current-shard</span>]}]}])
<span class="comment">; =&gt;</span>
<span class="comment">; {:a             :leaf</span>
<span class="comment">;  :b             :leaf</span>
<span class="comment">;  :current-shard &quot;global&quot;</span>
<span class="comment">;  :go-s1         {:x :leaf :current-shard &quot;s1&quot; :y {:current-shard &quot;s1&quot;}}</span>
<span class="comment">;  :c             :leaf</span>
<span class="comment">;  :go-s2         {:current-shard &quot;s2&quot; :now-s3 {:current-shard &quot;s3&quot;}}}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_testing_todo"><a class="anchor" href="#_testing_todo"></a><a class="link" href="#_testing_todo">3.8. Testing #TODO</a></h3>

</div>
<div class="sect2">
<h3 id="_placeholders"><a class="anchor" href="#_placeholders"></a><a class="link" href="#_placeholders">3.9. Placeholders</a></h3>
<div class="paragraph">
<p>There is one issue that some people stumbled upon while using Om.next; the problem happens when you need to display two or more different views of the same item as siblings (regarding query arrangement, not necessarily DOM siblings), how do you make this query?</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say you have two different components to display a user profile, one that shows just the username, and another one with its photo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(om/defui ^<span class="symbol">:once</span> UserTextView
  static om/IQuery
  (query [_] [<span class="symbol">:user/name</span>]))

(om/defui ^<span class="symbol">:once</span> UserImageView
  static om/IQuery
  (query [_] [<span class="symbol">:user/photo-url</span>]))

(om/defui ^<span class="symbol">:once</span> UserViewsCompare
  static om/IQuery
  <span class="comment">;; We want to query for both, what we place here?</span>
  (query [_] [{<span class="symbol">:app/current-user</span> [???]}]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might be tempted to <code>concat</code> the queries, and in case you don’t have to nest like we do here, that may even look like it’s working, but let me break this illusion for you; because it’s not. When you use om/get-query it’s not just the query that’s returned; it also contains meta-data telling from which component that query came from.</p>
</div>
<div class="paragraph">
<p>This information is important, <code>om</code> uses to index your structure and enables incremental updates. When you <code>concat</code> the queries, you lose this, and as a consequence, when you try to run a mutation later that touches those items you will have a <strong>“No queries exist at the intersection of component path”</strong> thrown in your face.</p>
</div>
<div class="paragraph">
<p>[This problem is still in discussion on the om repository](<a href="https://github.com/omcljs/om/issues/823" class="bare">https://github.com/omcljs/om/issues/823</a>). So far the best way I know to handle this is to use placeholder nodes, so let’s learn how to manage those cases properly.</p>
</div>
<div class="paragraph">
<p>What we need is to be able to branch out the different queries, this is my suggestion on how to write the <code>UserViewsCompare</code> query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(om/defui ^<span class="symbol">:once</span> UserViewsCompare
  static om/IQuery
  <span class="comment">;; By having extra possible branches we keep the path information working</span>
  (query [_] [{<span class="symbol">:app/current-user</span> [{<span class="symbol">:ph/text-view</span> (om/get-query UserTextView)}
                                  {<span class="symbol">:ph/image-view</span> (om/get-query UserImageView)}]}]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The trick is to create a convention about placeholder nodes, in this case, we choose the namespace ph to represent “placeholder nodes”, so when the query asks for <code>:ph/something</code> we should just do a recursive call, but staying at the same logical position in terms of parsing, as if we had stayed on the same node.</p>
</div>
<div class="paragraph">
<p>You can use the <code>p/placeholder-reader</code> to implement this pattern on your parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.placeholder</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">user</span>
  {<span class="symbol">:user/name</span>      <span class="string"><span class="delimiter">&quot;</span><span class="content">Walter White</span><span class="delimiter">&quot;</span></span>
   <span class="symbol">:user/photo-url</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">http://retalhoclub.com.br/wp-content/uploads/2016/07/1-3.jpg</span><span class="delimiter">&quot;</span></span>})

(<span class="keyword">def</span> <span class="function">computed</span>
  {<span class="symbol">:app/current-user</span>
   (<span class="keyword">fn</span> [env]
     (p/join user env))})

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [p/map-reader
                                                               computed
                                                               <span class="comment">; placeholder reader</span>
                                                               (p/placeholder-reader <span class="string"><span class="delimiter">&quot;</span><span class="content">ph</span><span class="delimiter">&quot;</span></span>)]})]}))

(parser {} [{<span class="symbol">:app/current-user</span> [{<span class="symbol">:ph/text-view</span> [<span class="symbol">:user/name</span>]}
                                {<span class="symbol">:ph/image-view</span> [<span class="symbol">:user/photo-url</span>]}]}])
<span class="comment">; #:app{:current-user #:ph{:text-view #:user{:name &quot;Walter White&quot;},</span>
<span class="comment">;                          :image-view #:user{:photo-url &quot;http://retalhoclub.com.br/wp-content/uploads/2016/07/1-3.jpg&quot;}}}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_profiling"><a class="anchor" href="#_profiling"></a><a class="link" href="#_profiling">3.10. Profiling</a></h3>
<div class="paragraph">
<p>It&#8217;s good to know how your queries are performing, and breaking it down by nodes is an excellent level to reason about how your queries are doing. Pathom provides a plugin to make this measurement easy to do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.profile</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.profile <span class="symbol">:as</span> p.profile]))

(<span class="keyword">def</span> <span class="function">computed</span>
  <span class="comment">; to demo delays, this property will take some time</span>
  {<span class="symbol">:expensive</span> (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
                (Thread/sleep <span class="integer">300</span>)
                (<span class="keyword">if</span> query
                  (p/join env)
                  <span class="symbol">:done</span>))})

(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

<span class="comment">; starting the parser as usual</span>
(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [computed flow-reader]})
                          <span class="comment">; include the profile plugin</span>
                          p.profile/profile-plugin]}))

(parser {}
        <span class="comment">; run the things</span>
        [<span class="symbol">:a</span> <span class="symbol">:b</span> {<span class="symbol">:expensive</span> [<span class="symbol">:c</span> <span class="symbol">:d</span> {<span class="symbol">:e</span> [<span class="symbol">:expensive</span>]}]}
         <span class="comment">; profile plugin provide this key, when you ask for it you get the</span>
         <span class="comment">; information, be sure to request this as the last item on your query</span>
         <span class="symbol">::p.profile/profile</span>])
<span class="comment">; =&gt;</span>
<span class="comment">; {:a                  :leaf</span>
<span class="comment">;  :b                  :leaf</span>
<span class="comment">;  :expensive          {:c :leaf</span>
<span class="comment">;                       :d :leaf</span>
<span class="comment">;                       :e {:expensive :done}}</span>
<span class="comment">;  ::p.profile/profile {:a         0</span>
<span class="comment">;                       :b         0</span>
<span class="comment">;                       :expensive {:c               1</span>
<span class="comment">;                                   :d               0</span>
<span class="comment">;                                   :e               {:expensive 304</span>
<span class="comment">;                                                     ::p.profile/self 304}</span>
<span class="comment">;                                   ::p.profile/self 611}}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Looking at the profile results, you see the query values, and at the edges is the <code>ms</code> time taken to process that node. When the node has children, a <code>::p.profile/self</code> indicates the time for the node itself (including children).</p>
</div>
<div class="paragraph">
<p>If you like to print a flame-graph of this output, you can use some d3 libraries on the web, I recommend the [d3 flame graph from spierman](<a href="https://github.com/spiermar/d3-flame-graph" class="bare">https://github.com/spiermar/d3-flame-graph</a>). Pathom has a function to convert the profile data to the format accepted by that library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">-&gt;</span> (parser {}
            <span class="comment">; let's add more things this time</span>
            [<span class="symbol">:a</span> {<span class="symbol">:b</span> [<span class="symbol">:g</span> {<span class="symbol">:expensive</span> [<span class="symbol">:f</span>]}]}
             {<span class="symbol">:expensive</span> [<span class="symbol">:c</span> <span class="symbol">:d</span> {<span class="symbol">:e</span> [<span class="symbol">:expensive</span>]}]}
             <span class="symbol">::p.profile/profile</span>])
    <span class="comment">; get the profile</span>
    <span class="symbol">::p.profile/profile</span>
    <span class="comment">; generate the name/value/children format</span>
    p.profile/profile-&gt;nvc)
<span class="comment">; =&gt;</span>
<span class="comment">; {:name     &quot;Root&quot;</span>
<span class="comment">;  :value    910</span>
<span class="comment">;  :children [{:name &quot;:a&quot; :value 0}</span>
<span class="comment">;             {:name     &quot;:b&quot;</span>
<span class="comment">;              :value    305</span>
<span class="comment">;              :children [{:name &quot;:g&quot; :value 0} {:name &quot;:expensive&quot; :value 304 :children [{:name &quot;:f&quot; :value 1}]}]}</span>
<span class="comment">;             {:name     &quot;:expensive&quot;</span>
<span class="comment">;              :value    605</span>
<span class="comment">;              :children [{:name &quot;:c&quot; :value 0}</span>
<span class="comment">;                         {:name &quot;:d&quot; :value 1}</span>
<span class="comment">;                         {:name &quot;:e&quot; :value 301 :children [{:name &quot;:expensive&quot; :value 300}]}]}]}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And then use that data to generate the flame graph:</p>
</div>
<div class="paragraph">
<p>![Profile demo](<a href="https://github.com/wilkerlucio/pathom/blob/master/doc-examples/images/profile-flame-demo.png" class="bare">https://github.com/wilkerlucio/pathom/blob/master/doc-examples/images/profile-flame-demo.png</a>)</p>
</div>
</div>
<div class="sect2">
<h3 id="_path_tracking"><a class="anchor" href="#_path_tracking"></a><a class="link" href="#_path_tracking">3.11. Path tracking</a></h3>
<div class="paragraph">
<p>As you go deep in your parser <code>pathom</code> track record of the current path taken, it&#8217;s available at <code>::p/path</code> at any time. It&#8217;s a vector containing the current path from the root, the current main use for it is regarding error reporting and profiling.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.path-tracking</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]))

(<span class="keyword">def</span> <span class="function">where-i-am-reader</span>
  {<span class="symbol">:where-am-i</span> (<span class="keyword">fn</span> [{<span class="symbol">::p/keys</span> [path]}] path)})

<span class="comment">; a reader that just flows, until it reaches a leaf</span>
(<span class="keyword">defn</span> <span class="function">flow-reader</span> [{<span class="symbol">:keys</span> [query] <span class="symbol">:as</span> env}]
  (<span class="keyword">if</span> query
    (p/join env)
    <span class="symbol">:leaf</span>))

(<span class="keyword">def</span> <span class="function">parser</span> (p/parser {<span class="symbol">::p/plugins</span> [(p/env-plugin {<span class="symbol">::p/reader</span> [where-i-am-reader
                                                               flow-reader]})]}))

(parser {} [{<span class="symbol">:hello</span> [<span class="symbol">:some</span> {<span class="symbol">:friend</span> [<span class="symbol">:place</span> <span class="symbol">:where-am-i</span>]}]}])
<span class="comment">;=&gt;</span>
<span class="comment">;{:hello {:some   :leaf</span>
<span class="comment">;         :friend {:place      :leaf</span>
<span class="comment">;                  :where-am-i [:hello :friend :where-am-i]}}}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_async_parsing_todo"><a class="anchor" href="#_async_parsing_todo"></a><a class="link" href="#_async_parsing_todo">3.12. Async parsing #TODO</a></h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_pathom_connect"><a class="anchor" href="#_pathom_connect"></a><a class="link" href="#_pathom_connect">4. Pathom Connect</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous sections we saw a way to implement parsers that are mostly driven by taking
an attribute and responding to it. But this implemention is opaque, you have no way to
introspect that system in a significant way. What <code>Connect</code> provides is a higher level
abstraction, by adding some constraints it&#8217;s handles the processing in a more automatic
way, based on an index that can be used for introspection later, enabling features like:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Auto-complete features for data exploration (see <a href="https://github.com/wilkerlucio/oge">OgE</a>)</p>
</li>
<li>
<p>Graph generation from the index connections information</p>
</li>
<li>
<p>Multiple entry points to an attribute, automatically resolved via check current available data</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>Connect</code> index is rich on information about how your attributes connect and how they
can locate each other.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s start to write some code too see how that works.</p>
</div>
<div class="sect2">
<h3 id="_using_connect"><a class="anchor" href="#_using_connect"></a><a class="link" href="#_using_connect">4.1. Using Connect</a></h3>
<div class="paragraph">
<p>In <code>Connect</code> you implement the graph by creating <code>resolvers</code>, those resolvers are functions that expose some data on the graph. In this tutorial, we are going to learn more about how to create resolvers by implementing a music store graph API.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s write some boilerplate to kickstart the project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.connect.getting-started</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> p.connect]))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span>
             [(p/env-plugin
                {<span class="symbol">::p/reader</span> [p/map-reader
                             p.connect/all-readers]})]}))

(<span class="keyword">comment</span>
  (parser {<span class="symbol">::p/entity</span> {<span class="symbol">:hello</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">World</span><span class="delimiter">&quot;</span></span>}} [<span class="symbol">:hello</span>]))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Connect</code> reader is used in conjunction with the <a href="#map-reader">map reader</a>, when the entity doesn&#8217;t have the information, <code>Connect</code> will be triggered to resolve the attribute.</p>
</div>
<div class="sect3">
<h4 id="_global_resolvers"><a class="anchor" href="#_global_resolvers"></a><a class="link" href="#_global_resolvers">4.1.1. Global resolvers</a></h4>
<div class="paragraph">
<p>To start simple, let&#8217;s create an entry point that provides the latest product we have in our store, to accomplish that we need to write a <code>resolver</code>, create an <code>index</code> and then use that to run our query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.connect.getting-started</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> p.connect]))

(<span class="keyword">defn</span> <span class="function">latest-product</span> [_ _]
  {<span class="symbol">::latest-product</span> {<span class="symbol">:product/id</span>    <span class="integer">1</span>
                     <span class="symbol">:product/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Acoustic Guitar</span><span class="delimiter">&quot;</span></span>
                     <span class="symbol">:product/price</span> <span class="float">199.99</span>M}})

(<span class="keyword">def</span> <span class="function">indexes</span>
  (<span class="keyword">-&gt;</span> {}
      <span class="comment">; note that we add the symbol of the resolver, not the function reference</span>
      (p.connect/add `latest-product
        {<span class="symbol">::p.connect/output</span> [{<span class="symbol">::latest-product</span> [<span class="symbol">:product/id</span> <span class="symbol">:product/title</span> <span class="symbol">:product/price</span>]}]})))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span>
             [(p/env-plugin
                {<span class="symbol">::p/reader</span>          [p/map-reader
                                      p.connect/all-readers]
                 <span class="symbol">::p.connect/indexes</span> indexes})]}))

(<span class="keyword">comment</span>
  (parser {} [<span class="symbol">::latest-product</span>]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have some rules for the <code>resolver</code> functions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It always takes two arguments:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>the environment, which is provided by the regular parser engine</p>
</li>
<li>
<p>a map containing the required input data for that <code>resolver</code> (more on this later).</p>
</li>
</ol>
</div>
</li>
<li>
<p>It must return a map, with at least one key.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The critical thing to notice here is: resolvers always take named parameters (input map) and always spit named attributes (output map). This structure enables for automatic attribute walking, which we will see later in this tutorial.</p>
</div>
<div class="paragraph">
<p>In our first resolver we expose the attribute <code>::latest-product</code>, and this resolver doesn&#8217;t require any input, from now one we will call those <code>global resolvers</code> (those which don&#8217;t require any input, so can be requested anywhere). Also, note that in our output description we have the full output details (including nested attributes), this is mostly useful for auto-complete on UI&#8217;s and automatic testing.</p>
</div>
<div class="paragraph">
<p>Play with some other queries to see what we can do at this point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">  (parser {} [<span class="symbol">::latest-product</span>])
  <span class="comment">; =&gt; #::{:latest-product #:product{:id 1, :title &quot;Acoustic Guitar&quot;, :price 199.99M}}</span>

  (parser {} [{<span class="symbol">::latest-product</span> [<span class="symbol">:product/title</span>]}])
  <span class="comment">; =&gt; #::{:latest-product #:product{:title &quot;Acoustic Guitar&quot;}}</span>

  <span class="comment">; ::latest-product can be requested anywhere</span>
  (parser {} [{<span class="symbol">::latest-product</span> ['<span class="keyword">*</span> <span class="symbol">::latest-product</span>]}])
  <span class="comment">; =&gt; #::{:latest-product {:product/id      1</span>
  <span class="comment">;                         :product/title   &quot;Acoustic Guitar&quot;</span>
  <span class="comment">;                         :product/price   199.99M</span>
  <span class="comment">;                         ::latest-product #:product{:id    1</span>
  <span class="comment">;                                                    :title &quot;Acoustic Guitar&quot;</span>
  <span class="comment">;                                                    :price 199.99M}}}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resolvers_with_input"><a class="anchor" href="#_resolvers_with_input"></a><a class="link" href="#_resolvers_with_input">4.1.2. Resolvers with input</a></h4>
<div class="paragraph">
<p>Next, let&#8217;s say we want to have a new attribute which is the brand of the product. Of course, we could just throw the data there, but to make it an attractive example, let&#8217;s pretend the brand information is fetched from a different place, which maps the product id to its brand.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">pathom-docs.connect.getting-started2</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.core <span class="symbol">:as</span> p]
            [com.wsscode.pathom.connect <span class="symbol">:as</span> p.connect]))

(<span class="keyword">def</span> <span class="function">product-&gt;brand</span>
  {<span class="integer">1</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Taylor</span><span class="delimiter">&quot;</span></span>})

(<span class="keyword">defn</span> <span class="function">product-brand</span> [_ {<span class="symbol">:keys</span> [product/id]}]
  {<span class="symbol">:product/brand</span> (<span class="keyword">get</span> product-&gt;brand id)})

(<span class="keyword">defn</span> <span class="function">latest-product</span> [_ _]
  {<span class="symbol">::latest-product</span> {<span class="symbol">:product/id</span>    <span class="integer">1</span>
                     <span class="symbol">:product/title</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Acoustic Guitar</span><span class="delimiter">&quot;</span></span>
                     <span class="symbol">:product/price</span> <span class="float">199.99</span>M}})

(<span class="keyword">def</span> <span class="function">indexes</span>
  (<span class="keyword">-&gt;</span> {}
      (p.connect/add `latest-product
        {<span class="symbol">::p.connect/output</span> [{<span class="symbol">::latest-product</span> [<span class="symbol">:product/id</span> <span class="symbol">:product/title</span> <span class="symbol">:product/price</span>]}]})
      (p.connect/add `product-brand
        {<span class="symbol">::p.connect/input</span> #{<span class="symbol">:product/id</span>}
         <span class="symbol">::p.connect/output</span> [<span class="symbol">:product/brand</span>]})))

(<span class="keyword">def</span> <span class="function">parser</span>
  (p/parser {<span class="symbol">::p/plugins</span>
             [(p/env-plugin
                {<span class="symbol">::p/reader</span>          [p/map-reader
                                      p.connect/all-readers]
                 <span class="symbol">::p.connect/indexes</span> indexes})]}))

(<span class="keyword">comment</span>
  (parser {} [{<span class="symbol">::latest-product</span> [<span class="symbol">:product/title</span> <span class="symbol">:product/brand</span>]}])
  <span class="comment">; =&gt; #::{:latest-product #:product{:title &quot;Acoustic Guitar&quot;, :brand &quot;Taylor&quot;}}</span>
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time we specify the <code>::p.connect/input</code> to our new <code>product-brand</code> resolver. This key receives a <code>set</code> containing the keys required on the current entity to run the resolver. And this is what powers the <code>Connect</code> engine, every time you need to access some specific attribute; it will try to figure it out based on the attributes the current entity has. <code>Connect</code> will also walk a dependency graph if it needs to, to illustrate this let&#8217;s pretend we have some external ID to the brand, and that we can derive this ID from the brand string, pretty much just another mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">brand-&gt;id</span>
  {<span class="string"><span class="delimiter">&quot;</span><span class="content">Taylor</span><span class="delimiter">&quot;</span></span> <span class="integer">44151</span>})

(<span class="keyword">defn</span> <span class="function">brand-id-from-name</span> [_ {<span class="symbol">:keys</span> [product/brand]}]
  {<span class="symbol">:product/brand-id</span> (<span class="keyword">get</span> brand-&gt;id brand)})

(<span class="keyword">def</span> <span class="function">indexes</span>
  (<span class="keyword">-&gt;</span> {}
      (p.connect/add `latest-product
        {<span class="symbol">::p.connect/output</span> [{<span class="symbol">::latest-product</span> [<span class="symbol">:product/id</span> <span class="symbol">:product/title</span> <span class="symbol">:product/price</span>]}]})
      (p.connect/add `product-brand
        {<span class="symbol">::p.connect/input</span> #{<span class="symbol">:product/id</span>}
         <span class="symbol">::p.connect/output</span> [<span class="symbol">:product/brand</span>]})
      (p.connect/add `brand-id-from-name
        {<span class="symbol">::p.connect/input</span> #{<span class="symbol">:product/brand</span>}
         <span class="symbol">::p.connect/output</span> [<span class="symbol">:product/brand-id</span>]})))

(<span class="keyword">comment</span>
  (parser {} [{<span class="symbol">::latest-product</span> [<span class="symbol">:product/title</span> <span class="symbol">:product/brand-id</span>]}])
  <span class="comment">; =&gt; #::{:latest-product #:product{:title &quot;Acoustic Guitar&quot;, :brand-id 44151}}</span>
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we never said anything about the <code>:product/brand</code> on this query, <code>Connect</code> automatically walked the path <code>:product/id &#8594; :product/brand &#8594; :product/brand-id</code>.</p>
</div>
<div class="paragraph">
<p>When a required attribute is not present in the current entity, <code>Connect</code> will look up if the missing attribute has a resolver to fetch it, in case it does, it will recursively restart the process until the chain is realized. This is what makes <code>Connect</code> powerful, by leveraging the index containing the attribute relationships, you can focus on writing just the <code>edges</code> of the graph, and then all paths can be walked automatically, you can read more about how this works in the Index page.</p>
</div>
<div class="paragraph">
<p>In case the path is a dead end (not enough data), <code>Connect</code> triggers an error explaining the miss. Let&#8217;s see that in action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(parser {} [<span class="symbol">:product/brand</span>])
<span class="comment">; CompilerException clojure.lang.ExceptionInfo: Attribute :product/brand is defined but requirements could not be met. {:attr :product/brand, :entity nil, :requirements (#{:product/id})}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, <code>Connect</code> will fire an error in case you try to access something and it&#8217;s not possible to get there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_inputs_todo"><a class="anchor" href="#_multiple_inputs_todo"></a><a class="link" href="#_multiple_inputs_todo">4.1.3. Multiple inputs #TODO</a></h4>

</div>
<div class="sect3">
<h4 id="_single_input_requirements"><a class="anchor" href="#_single_input_requirements"></a><a class="link" href="#_single_input_requirements">4.1.4. Single input requirements</a></h4>
<div class="paragraph">
<p>Up to this, we saw how to access a global entry using its attribute name, and how to expand an entity data by attribute discovery. Another significant entry point for the graph are idents. Idents are for queries that need to start from a single input, for example: <code>product by id</code>, <code>user by email</code>. We have for example a resolver to get the brand from the product id, so <code>:product/id</code> can be used to find that. Also the <code>:product/brand-id</code> can be realized from <code>:product/brand</code>. But how to set those at query time? Using idents!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(parser {} [{[<span class="symbol">:product/id</span> <span class="integer">1</span>] [<span class="symbol">:product/brand</span>]}])
<span class="comment">; =&gt; {[:product/id 1] #:product{:brand &quot;Taylor&quot;}}</span>

(parser {} [{[<span class="symbol">:product/brand</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Taylor</span><span class="delimiter">&quot;</span></span>] [<span class="symbol">:product/brand-id</span>]}])
<span class="comment">; =&gt; {[:product/brand &quot;Taylor&quot;] #:product{:brand-id 44151}}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>By using <code>idents</code> on the left side of the join, we are providing an initial context with a single attribute for the join. So when we create an ident join with <code>[:product/id 1]</code>, the right side will start with an entity containing <code>{:product/id 1}</code>, and the rest derives from that.</p>
</div>
</div>
<div class="sect3">
<h4 id="_connect_readers"><a class="anchor" href="#_connect_readers"></a><a class="link" href="#_connect_readers">4.1.5. Connect readers</a></h4>
<div class="paragraph">
<p>The <code>p.connect/all-readers</code> is a combination of a few readers used by connect, let&#8217;s talk
about each reader individually.</p>
</div>
<div class="sect4">
<h5 id="_code_p_connect_reader_code"><a class="anchor" href="#_code_p_connect_reader_code"></a><a class="link" href="#_code_p_connect_reader_code"><code>p.connect/reader</code></a></h5>
<div class="paragraph">
<p>The main <code>Connect</code> reader. This will look up the attribute on the index and tries to resolve it. If you need extra
dependencies that are not available, will recursively try to resolve until it reaches the data.</p>
</div>
</div>
<div class="sect4">
<h5 id="connect-ident-reader"><a class="anchor" href="#connect-ident-reader"></a><a class="link" href="#connect-ident-reader"><code>p.connect/ident-reader</code></a></h5>
<div class="paragraph">
<p>The <code>ident-reader</code> enables us to start ident based queries. When an ident query is reaches
this reader, it will check on the index to see if the ident key is present on <a href="#connect-index-idents">idents</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_code_p_connect_index_reader_code"><a class="anchor" href="#_code_p_connect_index_reader_code"></a><a class="link" href="#_code_p_connect_index_reader_code"><code>p.connect/index-reader</code></a></h5>
<div class="paragraph">
<p>This reader exposes the index itself with the name <code>::p.connect/indexes</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_understanding_the_indexes"><a class="anchor" href="#_understanding_the_indexes"></a><a class="link" href="#_understanding_the_indexes">4.2. Understanding the indexes</a></h3>
<div class="paragraph">
<p><code>Connect</code> maintains a few indexes containg information about the <code>resolvers</code> and the
relationships on attributes. <code>Connect</code> will look up the index in the environment, on the
key <code>:com.wsscode.pathom.connect/indexes</code>, this is a map containing the indexes inside
of it. On this topic we are going to learn how they are organized and for what purpose
each one serves. To use as example, we will look at the index generated by our previous
example on the getting started section, let&#8217;s take a look at it now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">{<span class="symbol">::p.connect/index-resolvers</span>
 {get-started/latest-product
  {<span class="symbol">::p.connect/sym</span>    get-started/latest-product
   <span class="symbol">::p.connect/input</span>  #{}
   <span class="symbol">::p.connect/output</span> [{<span class="symbol">::get-started/latest-product</span> [<span class="symbol">:product/id</span>
                                                      <span class="symbol">:product/title</span>
                                                      <span class="symbol">:product/price</span>]}]}

  get-started/product-brand
  {<span class="symbol">::p.connect/sym</span>    get-started/product-brand
   <span class="symbol">::p.connect/input</span>  #{<span class="symbol">:product/id</span>}
   <span class="symbol">::p.connect/output</span> [<span class="symbol">:product/brand</span>]}

  get-started/brand-id-from-name
  {<span class="symbol">::p.connect/sym</span>    get-started/brand-id-from-name
   <span class="symbol">::p.connect/input</span>  #{<span class="symbol">:product/brand</span>}
   <span class="symbol">::p.connect/output</span> [<span class="symbol">:product/brand-id</span>]}}

 <span class="symbol">::p.connect/index-oir</span>
 {<span class="symbol">:get-started/latest-product</span> {#{} #{get-started/latest-product}}
  <span class="symbol">:product/brand</span>              {#{<span class="symbol">:product/id</span>} #{get-started/product-brand}}
  <span class="symbol">:product/brand-id</span>           {#{<span class="symbol">:product/brand</span>} #{get-started/brand-id-from-name}}}

 <span class="symbol">::p.connect/index-io</span>
 {#{}               {<span class="symbol">:get-started/latest-product</span> <span class="error">#</span><span class="symbol">:product</span>{<span class="symbol">:id</span> {} <span class="symbol">:title</span> {} <span class="symbol">:price</span> {}}}
  #{<span class="symbol">:product/id</span>}    {<span class="symbol">:product/brand</span> {}}
  #{<span class="symbol">:product/brand</span>} {<span class="symbol">:product/brand-id</span> {}}}

 <span class="symbol">::p.connect/idents</span>
 #{<span class="symbol">:product/brand</span> <span class="symbol">:product/id</span>}}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_code_index_resolvers_code"><a class="anchor" href="#_code_index_resolvers_code"></a><a class="link" href="#_code_index_resolvers_code">4.2.1. <code>index-resolvers</code></a></h4>
<div class="paragraph">
<p>This is a raw index of available resolvers, it&#8217;s a map <code>resolver-sym &#8594; resolver-data</code>.
<code>resolver-data</code> is any information relevant that you want to add about that resolver. Any
key that you adding during <code>p.connect/add</code> will end up on this map, also <code>Connect</code> will
add the key <code>::p.connect/sym</code> automatically, which is the same symbol you added. If you
want to access the data for a <code>resolver</code>, <code>Connect</code> provides a helper function for that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(p.connect/resolver-data env-or-indexes `product-brand)
<span class="comment">; =&gt; {::p.connect/sym    get-started/product-brand</span>
<span class="comment">;     ::p.connect/input  #{:product/id}</span>
<span class="comment">;     ::p.connect/output [:product/brand]}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_code_index_oir_code"><a class="anchor" href="#_code_index_oir_code"></a><a class="link" href="#_code_index_oir_code">4.2.2. <code>index-oir</code></a></h4>
<div class="paragraph">
<p>This index stands for <code>output &#8594; input &#8594; resolver</code>, it&#8217;s the index used for the <code>Connect</code>
reader to lookup the attributes. This index is built by looking at the output for the
resolver when you add it, it will use each root output attribute and save that resolver
as a path to that attribute, given that input. It kind of inverts the order of things,
it puts the output attribute at the front, and then the path to get to it.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s do an exercise and see how connect traverses this index in a practical example:</p>
</div>
<div class="paragraph">
<p>Given we have this index (oir):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.connect.index-oir-example</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.connect <span class="symbol">:as</span> pc]))

(<span class="keyword">def</span> <span class="function">indexes</span>
  (<span class="keyword">-&gt;</span> {}
      (pc/add 'thing-by-id {<span class="symbol">::pc/input</span>  #{<span class="symbol">:id</span>}
                            <span class="symbol">::pc/output</span> [<span class="symbol">:id</span> <span class="symbol">:name</span> <span class="symbol">:color</span>]})
      (pc/add 'thing-by-name {<span class="symbol">::pc/input</span>  #{<span class="symbol">:name</span>}
                              <span class="symbol">::pc/output</span> [<span class="symbol">:id</span> <span class="symbol">:name</span> <span class="symbol">:color</span>]})))

<span class="comment">; index-oir:</span>
'{<span class="symbol">:name</span>  {#{<span class="symbol">:id</span>} #{thing-by-id}}
  <span class="symbol">:color</span> {#{<span class="symbol">:id</span>}   #{thing-by-id}
          #{<span class="symbol">:name</span>} #{thing-by-name}}
  <span class="symbol">:id</span>    {#{<span class="symbol">:name</span>} #{thing-by-name}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if you try to run the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[<span class="symbol">:name</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we look on the index for <code>:name</code>, and we get <code>{#{:id} #{thing-by-id}}</code>, now we try
to match the current entity attribute keys with the sets, to see if we have enough
data to call some of then. In this case we don&#8217;t, so it will fail because we don&#8217;t have
enough data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{[<span class="symbol">:id</span> <span class="integer">123</span>] [<span class="symbol">:name</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time set an id, our initial context is <code>{:id 123}</code>. This time we have the <code>:id</code>, so
it will match with the input set <code>#{:id}</code>, and will call the resolver <code>thing-by-id</code> with
that input to figure the name. Connect uses <a href="#atom-entities">atom entities</a>, when it
gets the return from the resolver it merges it back on the entities, making all data
returned from the resolver available to access new attributes as needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_code_index_io_code"><a class="anchor" href="#_code_index_io_code"></a><a class="link" href="#_code_index_io_code">4.2.3. <code>index-io</code></a></h4>
<div class="paragraph">
<p>The auto-complete index, <code>input &#8594; output</code>. This index accumulates all the reach for
each single attribute on the index. By walking this information we can know ahead of
time all attribute possibilities we can fetch from a given attribute. In our example,
if we were given the attribute <code>:product/id</code>, what attributes can we fetch from that?</p>
</div>
<div class="paragraph">
<p>If I have a <code>:product/id</code>, what can I reach from it? Looking at the index, the <code>:product/id</code>
itself can provide the <code>:product/brand</code>. But if I have access to <code>:product/brand</code> it means
I also have access to whatever <code>:product/brand</code> can provide. By doing multiple iterations
(until there are no new attributes) we end up knowing that <code>:product/id</code> can provide the
attributes <code>:product/brand</code> and <code>:product/brand-id</code>. And this is how autocomplete is
done via the <code>index-io</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="connect-index-idents"><a class="anchor" href="#connect-index-idents"></a><a class="link" href="#connect-index-idents">4.2.4. <code>idents</code></a></h4>
<div class="paragraph">
<p>The <code>idents</code> index contain information about which single attributes can be used to access
some information. This index is used on <a href="#connect-ident-reader">ident-reader</a> and on
<code>OgE</code> to provide auto-complete options for idents. Any time you add a resolver that has
a single input, that input attribute is added on the <code>idents</code> index.</p>
</div>
</div>
<div class="sect3">
<h4 id="_code_autocomplete_ignore_code"><a class="anchor" href="#_code_autocomplete_ignore_code"></a><a class="link" href="#_code_autocomplete_ignore_code">4.2.5. <code>autocomplete-ignore</code></a></h4>
<div class="paragraph">
<p>This index is for a more advanced usage. Currently it&#8217;s only used by the <code>GraphQL</code> integration.
On the <code>GraphQL</code> integration we leverage the fact that types have a fixed set of attributes
and add that into the index. The problem is that the types thenselves are not valid entries
for the query, then <code>autocomplete-ignore</code> is a way to make those things be ignored in
the auto-complete. You probably only need this if you are building the index in some
custom way.</p>
</div>
</div>
<div class="sect3">
<h4 id="_merging_indexes_todo"><a class="anchor" href="#_merging_indexes_todo"></a><a class="link" href="#_merging_indexes_todo">4.2.6. Merging indexes #TODO</a></h4>

</div>
</div>
<div class="sect2">
<h3 id="_auto_testing_todo"><a class="anchor" href="#_auto_testing_todo"></a><a class="link" href="#_auto_testing_todo">4.3. Auto testing #TODO</a></h3>

</div>
<div class="sect2">
<h3 id="_exploration_with_oge_todo"><a class="anchor" href="#_exploration_with_oge_todo"></a><a class="link" href="#_exploration_with_oge_todo">4.4. Exploration with OgE #TODO</a></h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_graphql_integration"><a class="anchor" href="#_graphql_integration"></a><a class="link" href="#_graphql_integration">5. GraphQL Integration</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Pathom provides a collection of utilities to integrate with GraphQL. In the following
sections you gonna learn a couple of different ways to make this integration.</p>
</div>
<div class="sect2">
<h3 id="_fulcro_network"><a class="anchor" href="#_fulcro_network"></a><a class="link" href="#_fulcro_network">5.1. Fulcro Network</a></h3>
<div class="paragraph">
<p>Thanks to a feature parity with GraphQL, it is possible to use a GraphQL endpoint directly
from the client.</p>
</div>
<div class="sect3">
<h4 id="_pulling_data"><a class="anchor" href="#_pulling_data"></a><a class="link" href="#_pulling_data">5.1.1. Pulling data</a></h4>
<div class="paragraph">
<p>Github provides a <a href="https://developer.github.com/v4">public GraphQL API</a>. Let&#8217;s see how
we can read some data strait from then. Using the <a href="https://developer.github.com/v4/explorer/">explorer</a>,
try the following query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="graphql">query {
  viewer {
    id
    name
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This should print your id and name. In EDN syntax, we can write an equivalent query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">[{<span class="symbol">:viewer</span>
  [<span class="symbol">:id</span> <span class="symbol">:name</span>]}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check the <a href="#edn_gql">EDN&#8594;GraphQL</a> tool for more translation examples.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s build a view using that query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.graphql.fulcro-network.github-name</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.fulcro.network <span class="symbol">:as</span> pfn] <span class="comment">; </span><b class="conum">(1)</b>
            [fulcro.client <span class="symbol">:as</span> fulcro]
            [fulcro.client.dom <span class="symbol">:as</span> dom]
            [fulcro.client.data-fetch <span class="symbol">:as</span> df]
            [fulcro.client.primitives <span class="symbol">:as</span> fp]))

(fp/defsc GithubUserView
  [this {<span class="symbol">:keys</span> [<span class="keyword">name</span>] <span class="symbol">:as</span> props}]
  {<span class="symbol">:query</span> [<span class="symbol">:id</span> <span class="symbol">:name</span> [df/marker-table <span class="symbol">::loading</span>]] <span class="comment">; </span><b class="conum">(2)</b>
   <span class="symbol">:ident</span> [<span class="symbol">:id</span> <span class="symbol">:id</span>]}
  (<span class="keyword">let</span> [marker (<span class="keyword">get</span> props [df/marker-table <span class="symbol">::loading</span>])]
    (dom/div <span class="predefined-constant">nil</span>
      (<span class="keyword">cond</span>
        <span class="keyword">name</span>
        (<span class="keyword">str</span> <span class="keyword">name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">, congrats on your Fulcro + GraphQL integration!</span><span class="delimiter">&quot;</span></span>)

        (df/loading? marker)
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>

        <span class="symbol">:else</span>
        (dom/button <span class="error">#</span>js {<span class="symbol">:onClick</span> <span class="comment">; </span><b class="conum">(3)</b>
                         #(df/load this <span class="symbol">:viewer</span> GithubUserView {<span class="symbol">:target</span> [<span class="symbol">:ui/root</span>]
                                                                <span class="symbol">:marker</span> <span class="symbol">::loading</span>})}
          <span class="string"><span class="delimiter">&quot;</span><span class="content">Load name</span><span class="delimiter">&quot;</span></span>)))))

(<span class="keyword">def</span> <span class="function">github-user-view</span> (fp/factory GithubUserView {<span class="symbol">:keyfn</span> <span class="symbol">:id</span>}))

(fp/defsc Root
  [_ {<span class="symbol">:keys</span> [viewer]}]
  {<span class="symbol">:query</span> [{<span class="symbol">:viewer</span> (fp/get-query GithubUserView)}]} <span class="comment">; </span><b class="conum">(4)</b>
  (github-user-view viewer))

(<span class="keyword">defn</span> <span class="function">new-client</span> [token]
  (fulcro/new-fulcro-client
    <span class="symbol">:networking</span>
    {<span class="symbol">:remote</span>
     (pfn/graphql-network <span class="comment">; </span><b class="conum">(5)</b>
       {<span class="symbol">::pfn/url</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://api.github.com/graphql?access_token=</span><span class="delimiter">&quot;</span></span> token)})}))</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Require the namespace containing the fulcro network helpers</p>
</li>
<li>
<p>We get just the subquery related to the user data and put in this component</p>
</li>
<li>
<p>Trigger the load for the <code>:viewer</code></p>
</li>
<li>
<p>The viewer goes on the root query</p>
</li>
<li>
<p>Setup the GraphQL network, it&#8217;s a Fulcro network that does the query translation automatically</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can try this example here, you need to <a href="https://github.com/settings/tokens">generate a personal token on Github</a>,
please add <code>public_repo</code> scope when you generate it, so you can try all the following demos.</p>
</div>
<div x-app="demo-fulcro-network-github-name"></div>
<div class="space"></div>
<div class="paragraph">
<p>What were the last projects you Github that you gave a star to? First let&#8217;s see what
the query for it looks like (the EDN is editable, <a href="https://shaunlebron.github.io/parinfer/">parinfer activated</a>):</p>
</div>
<div x-app="inline-edn-graphql-converter" class="loader">
[{:viewer
  [{(:starred-repositories {:first    10
                            :order-by {:field     STARRED_AT
                                       :direction DESC}})
    [{:nodes
      [:id :name :updated-at]}]}]}]
</div>
<div class="paragraph">
<p>With the query on hand we can start a new view for it. Note on this demo we are starting
to use namespaced keywords on our properties. The namespaces are simply remove when
the GraphQL is generated, but they are restored once the result is parsed back.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.graphql.fulcro-network.github-latest-stars</span>
  (<span class="symbol">:require</span> [com.wsscode.pathom.book.ui.util <span class="symbol">:as</span> ui]
            [com.wsscode.pathom.fulcro.network <span class="symbol">:as</span> pfn]
            [fulcro.client <span class="symbol">:as</span> fulcro]
            [fulcro.client.data-fetch <span class="symbol">:as</span> df]
            [fulcro.client.dom <span class="symbol">:as</span> dom]
            [fulcro.client.primitives <span class="symbol">:as</span> fp]))

(fp/defsc Repository
  [this {<span class="symbol">:github.repository/keys</span> [name-with-owner]} _ css]
  {<span class="symbol">:ident</span> [<span class="symbol">:github.repository/id</span> <span class="symbol">:github.repository/id</span>]
   <span class="comment">; here is the item query for each repository, remember the namespaces will just be</span>
   <span class="comment">; removed to call the graphql api</span>
   <span class="symbol">:query</span> [<span class="symbol">:github.repository/id</span>
           <span class="symbol">:github.repository/name-with-owner</span>]
   <span class="symbol">:css</span>   [[<span class="symbol">:.</span>container {<span class="symbol">:margin</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">4px 0</span><span class="delimiter">&quot;</span></span>}]]}
  (dom/div <span class="error">#</span>js {<span class="symbol">:className</span> (<span class="symbol">:container</span> css)}
    (<span class="keyword">str</span> name-with-owner)))

(<span class="keyword">def</span> <span class="function">repository</span> (fp/factory Repository {<span class="symbol">:keyfn</span> <span class="symbol">:github.repository/id</span>}))

(fp/defsc LastestStarred
  [this {<span class="symbol">:keys</span> [github/starred-repositories]} _ css]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_] {})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">::starred</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">singleton</span><span class="delimiter">&quot;</span></span>])
   <span class="symbol">:query</span>         (<span class="keyword">fn</span> [] <span class="comment">; the container query, adding the params to fix the size</span>
                         <span class="comment">; and order</span>
                    [{'(<span class="symbol">:github/starred-repositories</span> {<span class="symbol">:first</span>    <span class="integer">10</span>
                                                      <span class="symbol">:order-by</span> {<span class="symbol">:field</span>     STARRED_AT
                                                                 <span class="symbol">:direction</span> DESC}})
                      [{<span class="symbol">:nodes</span> (fp/get-query Repository)}]}
                     [df/marker-table <span class="symbol">::loading</span>]])
   <span class="symbol">:css</span>           [[<span class="symbol">:.</span>title {<span class="symbol">:margin-bottom</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">8px</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">:font-weight</span>   <span class="string"><span class="delimiter">&quot;</span><span class="content">bold</span><span class="delimiter">&quot;</span></span>}]
                   [<span class="symbol">:.</span>button {<span class="symbol">:margin-top</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">10px</span><span class="delimiter">&quot;</span></span>}]]
   <span class="symbol">:css-include</span>   [Repository]}
  (<span class="keyword">let</span> [loading? (ui/loading? this <span class="symbol">::loading</span>)]
    (dom/div <span class="predefined-constant">nil</span>
      (<span class="keyword">cond</span>
        starred-repositories
        (dom/div <span class="predefined-constant">nil</span>
          (dom/div <span class="error">#</span>js {<span class="symbol">:className</span> (<span class="symbol">:title</span> css)} <span class="string"><span class="delimiter">&quot;</span><span class="content">The last repositories you added a star to:</span><span class="delimiter">&quot;</span></span>)
          (<span class="keyword">map</span> repository (<span class="symbol">:nodes</span> starred-repositories))
          (dom/button <span class="error">#</span>js {<span class="symbol">:onClick</span>   #(df/load this <span class="symbol">:viewer</span> LastestStarred {<span class="symbol">:target</span> [<span class="symbol">:ui/root</span>]
                                                                             <span class="symbol">:marker</span> <span class="symbol">::loading</span>})
                           <span class="symbol">:className</span> (<span class="symbol">:button</span> css)
                           <span class="symbol">:disabled</span>  loading?}
            (<span class="keyword">if</span> loading? <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Reload</span><span class="delimiter">&quot;</span></span>)))

        loading?
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Loading...</span><span class="delimiter">&quot;</span></span>

        <span class="symbol">:else</span>
        (dom/button <span class="error">#</span>js {<span class="symbol">:onClick</span>
                         #(df/load this <span class="symbol">:viewer</span> LastestStarred {<span class="symbol">:target</span> [<span class="symbol">:ui/root</span>]
                                                                <span class="symbol">:marker</span> <span class="symbol">::loading</span>})}
          <span class="string"><span class="delimiter">&quot;</span><span class="content">Load latest starred repositories</span><span class="delimiter">&quot;</span></span>)))))

(<span class="keyword">defn</span> <span class="function">new-client</span> [token]
  (fulcro/new-fulcro-client
    <span class="symbol">:networking</span>
    {<span class="symbol">:remote</span>
     (pfn/graphql-network
       {<span class="symbol">::pfn/url</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://api.github.com/graphql?access_token=</span><span class="delimiter">&quot;</span></span> token)})}))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Demo:</p>
</div>
<div x-app="demo-fulcro-network-github-latest-stars"></div>
</div>
<div class="sect3">
<h4 id="_calling_mutations"><a class="anchor" href="#_calling_mutations"></a><a class="link" href="#_calling_mutations">5.1.2. Calling mutations</a></h4>
<div class="paragraph">
<p>At some point, we might wanna change things, so it&#8217;s time for mutations! To demonstrate
how to use mutations, we will write an app that can add star to some projects on Github.</p>
</div>
<div class="paragraph">
<p>This time let&#8217;s try the app first:</p>
</div>
<div x-app="demo-fulcro-network-github-stars"></div>
<div class="space"></div>
<div class="paragraph">
<p>Before this example we only used the <code>viewer</code> entry point. But in this example we are
not getting data related to the user directly, but instead we need specific repositories
from the Github API. When we want to query for single entities on Pathom/Fulcro, we use
ident queries, and the query translation is ready to deal with then:</p>
</div>
<div x-app="inline-edn-graphql-converter" class="loader">
[{[:github.user/login "richhickey"]
  [:github.user/name
   :github.user/avatar-url
   :github.user/website-url]}]
</div>
<div class="paragraph">
<p>To build the selector join from the ident, we use the last namespace segment and the
name of the keyword. There are some cases on GraphQL where the ident requires more than
one attribute, and repositories on Github are one example, they require a <code>owner</code> and
a <code>name</code>. To work around this Pathom uses an <code>-and-</code> convention on the ident name, eg:</p>
</div>
<div x-app="inline-edn-graphql-converter" class="loader">
[{[:github.repository/owner-and-name ["wilkerlucio" "pathom"]]
  [:github.repository/id :github.repository/name :github.repository/viewer-has-starred]}]
</div>
<div class="paragraph">
<p>To handle this inside our code, we make the <code>ident</code> constructor to return this key based
on some other attributes, in this case there is an attribute called <code>nameWithOwner</code> from
which we can extract both name and owner, see the details on the full source:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">ns</span> <span class="namespace">com.wsscode.pathom.book.graphql.fulcro-network.github-mutation-stars</span>
  (<span class="symbol">:require</span> [clojure.string <span class="symbol">:as</span> <span class="keyword">str</span>]
            [com.wsscode.pathom.fulcro.network <span class="symbol">:as</span> pfn]
            [fulcro.client <span class="symbol">:as</span> fulcro]
            [fulcro.client.dom <span class="symbol">:as</span> dom]
            [fulcro.client.mutations <span class="symbol">:as</span> mutations]
            [fulcro.client.primitives <span class="symbol">:as</span> fp]))

<span class="comment">; define the mutation as usual, the mutation name will be converted to camelCase and</span>
<span class="comment">; sent to GraphQL, same for the parameters</span>
(mutations/defmutation add-star [_]
  (action [{<span class="symbol">:keys</span> [state <span class="keyword">ref</span>]}]
    (<span class="keyword">swap!</span> state <span class="keyword">update-in</span> <span class="keyword">ref</span> <span class="keyword">assoc</span> <span class="symbol">:github.repository/viewer-has-starred</span> <span class="predefined-constant">true</span>))
  (remote [_] <span class="predefined-constant">true</span>))

(fp/defsc StarRepo
  [this {<span class="symbol">:github.repository/keys</span> [id <span class="keyword">name</span> name-with-owner viewer-has-starred]} _ css]
  {<span class="symbol">:initial-state</span> {}
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> []
                    <span class="comment">; notice we use the real data from name-with-owner to create our</span>
                    <span class="comment">; virtual ident that correctly maps to the entry query on graphql</span>
                    (<span class="keyword">let</span> [[owner <span class="keyword">name</span>] (str/split name-with-owner <span class="regexp"><span class="delimiter">#&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)]
                      [<span class="symbol">:github.repository/owner-and-name</span> [owner <span class="keyword">name</span>]]))
   <span class="symbol">:query</span>         [<span class="symbol">:github.repository/id</span>
                   <span class="symbol">:github.repository/name</span>
                   <span class="symbol">:github.repository/name-with-owner</span>
                   <span class="symbol">:github.repository/viewer-has-starred</span>]
   <span class="symbol">:css</span>           [[<span class="symbol">:div</span> [<span class="symbol">:.</span>button {<span class="symbol">:display</span>     <span class="string"><span class="delimiter">&quot;</span><span class="content">flex</span><span class="delimiter">&quot;</span></span>
                                    <span class="symbol">:align-items</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">center</span><span class="delimiter">&quot;</span></span>
                                    <span class="symbol">:margin</span>      <span class="string"><span class="delimiter">&quot;</span><span class="content">0 0 14px</span><span class="delimiter">&quot;</span></span>}]]
                   [<span class="symbol">:.</span>heart {<span class="symbol">:text-shadow</span>   <span class="string"><span class="delimiter">&quot;</span><span class="content">0 0 0 #adadad</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">:color</span>         <span class="string"><span class="delimiter">&quot;</span><span class="content">transparent</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">:transition</span>    <span class="string"><span class="delimiter">&quot;</span><span class="content">text-shadow 300ms</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">:font-size</span>     <span class="string"><span class="delimiter">&quot;</span><span class="content">28px</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">:margin-bottom</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">-3px</span><span class="delimiter">&quot;</span></span>
                             <span class="symbol">:margin-right</span>  <span class="string"><span class="delimiter">&quot;</span><span class="content">14px</span><span class="delimiter">&quot;</span></span>}
                    [<span class="symbol">:&amp;.red</span> {<span class="symbol">:text-shadow</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">0 0 0 #f50909</span><span class="delimiter">&quot;</span></span>}]]]
   <span class="symbol">:css-include</span>   []}
  (dom/div <span class="predefined-constant">nil</span>
                              <span class="comment">; here we call the mutation, we need to ask for some response</span>
                              <span class="comment">; otherwise the graphql will complain</span>
    (dom/button <span class="error">#</span>js {<span class="symbol">:onClick</span>   #(fp/transact! this `[{(add-star {<span class="symbol">:input</span> {<span class="symbol">:starrable-id</span> ~id}})
                                                       [<span class="symbol">:client-mutation-id</span>]}])
                     <span class="symbol">:disabled</span>  viewer-has-starred
                     <span class="symbol">:className</span> (<span class="symbol">:button</span> css)}
      (dom/div <span class="error">#</span>js {<span class="symbol">:className</span> (<span class="keyword">str</span> (<span class="symbol">:heart</span> css) <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>
                                    (<span class="keyword">if</span> viewer-has-starred (<span class="symbol">:red</span> css)))}
        <span class="string"><span class="delimiter">&quot;</span><span class="content">❤️</span><span class="delimiter">&quot;</span></span>)
      (<span class="keyword">if</span> viewer-has-starred
        (dom/div <span class="predefined-constant">nil</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Great, thanks for the </span><span class="delimiter">&quot;</span></span> (dom/strong <span class="predefined-constant">nil</span> <span class="keyword">name</span>) <span class="string"><span class="delimiter">&quot;</span><span class="content"> love!</span><span class="delimiter">&quot;</span></span>)
        (dom/div <span class="predefined-constant">nil</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Give love (star) to </span><span class="delimiter">&quot;</span></span> (dom/strong <span class="predefined-constant">nil</span> <span class="keyword">name</span>))))))

(<span class="keyword">def</span> <span class="function">star-repo</span> (fp/factory StarRepo {<span class="symbol">:keyfn</span> <span class="symbol">:github.repository/name-with-owner</span>}))

(fp/defsc GithubStars [_ {<span class="symbol">::keys</span> [repos]} _ css]
  {<span class="symbol">:initial-state</span> (<span class="keyword">fn</span> [_]
                    <span class="comment">; here we initialize our entities, we must use the name-with-owner</span>
                    <span class="comment">; so the ident is properly generated</span>
                    {<span class="symbol">::repos</span> [<span class="error">#</span><span class="symbol">:github.repository</span>{<span class="symbol">:name-with-owner</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">wilkerlucio/pathom</span><span class="delimiter">&quot;</span></span>}
                              <span class="error">#</span><span class="symbol">:github.repository</span>{<span class="symbol">:name-with-owner</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic/fulcro</span><span class="delimiter">&quot;</span></span>}
                              <span class="error">#</span><span class="symbol">:github.repository</span>{<span class="symbol">:name-with-owner</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic/fulcro-inspect</span><span class="delimiter">&quot;</span></span>}
                              <span class="error">#</span><span class="symbol">:github.repository</span>{<span class="symbol">:name-with-owner</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic/fulcro-css</span><span class="delimiter">&quot;</span></span>}
                              <span class="error">#</span><span class="symbol">:github.repository</span>{<span class="symbol">:name-with-owner</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic/fulcro-spec</span><span class="delimiter">&quot;</span></span>}
                              <span class="error">#</span><span class="symbol">:github.repository</span>{<span class="symbol">:name-with-owner</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">thheller/shadow-cljs</span><span class="delimiter">&quot;</span></span>}]})
   <span class="symbol">:ident</span>         (<span class="keyword">fn</span> [] [<span class="symbol">::github-stars</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">singleton</span><span class="delimiter">&quot;</span></span>])
   <span class="symbol">:query</span>         [{<span class="symbol">::repos</span> (fp/get-query StarRepo)}]
   <span class="symbol">:css</span>           [[<span class="symbol">:.</span>container {<span class="symbol">:columns</span>    <span class="integer">2</span>
                                 <span class="symbol">:margin-top</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">18px</span><span class="delimiter">&quot;</span></span>}]]
   <span class="symbol">:css-include</span>   [StarRepo]}
  (dom/div <span class="predefined-constant">nil</span>
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Use the buttons bellow to send love to our favorite UI kit tools!</span><span class="delimiter">&quot;</span></span>
    (dom/div <span class="error">#</span>js {<span class="symbol">:className</span> (<span class="symbol">:container</span> css)}
      (<span class="keyword">if</span> (<span class="keyword">-&gt;</span> repos <span class="keyword">first</span> <span class="symbol">:github.repository/id</span>)
        (<span class="keyword">map</span> star-repo repos)))))

(<span class="keyword">defn</span> <span class="function">new-client</span> [token]
  (fulcro/new-fulcro-client
    <span class="symbol">:started-callback</span>
    (<span class="keyword">fn</span> [{<span class="symbol">:keys</span> [reconciler]}]
      (fp/transact! reconciler
        [(<span class="keyword">list</span> 'fulcro/load
           <span class="comment">; triggering the load, now use have to use the ident with vector version so</span>
           <span class="comment">; it gets translated into the proper graphql query</span>
           {<span class="symbol">:query</span>   [{[<span class="symbol">:github.repository/owner-and-name</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">wilkerlucio</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">pathom</span><span class="delimiter">&quot;</span></span>]] (fp/get-query StarRepo)}
                      {[<span class="symbol">:github.repository/owner-and-name</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro</span><span class="delimiter">&quot;</span></span>]] (fp/get-query StarRepo)}
                      {[<span class="symbol">:github.repository/owner-and-name</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-inspect</span><span class="delimiter">&quot;</span></span>]] (fp/get-query StarRepo)}
                      {[<span class="symbol">:github.repository/owner-and-name</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-css</span><span class="delimiter">&quot;</span></span>]] (fp/get-query StarRepo)}
                      {[<span class="symbol">:github.repository/owner-and-name</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">fulcrologic</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">fulcro-spec</span><span class="delimiter">&quot;</span></span>]] (fp/get-query StarRepo)}
                      {[<span class="symbol">:github.repository/owner-and-name</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">thheller</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">shadow-cljs</span><span class="delimiter">&quot;</span></span>]] (fp/get-query StarRepo)}]
            <span class="symbol">:refresh</span> [<span class="symbol">::repos</span>]})]))

    <span class="symbol">:networking</span>
    {<span class="symbol">:remote</span>
     (<span class="keyword">-&gt;</span> (pfn/graphql-network
           {<span class="symbol">::pfn/url</span> (<span class="keyword">str</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">https://api.github.com/graphql?access_token=</span><span class="delimiter">&quot;</span></span> token)})
         (pfn/batch-network))}))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_reads_future"><a class="anchor" href="#_custom_reads_future"></a><a class="link" href="#_custom_reads_future">5.1.3. Custom reads #future</a></h4>
<div class="paragraph">
<p>Not available yet. The current GraphQL fails to have a good extension engine, it simply
does the translations and throw over the network, converting it back. Future versions
will support a more extensible engine so you can combine graphql, local reads, rest
services and etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_crud_example_todo"><a class="anchor" href="#_crud_example_todo"></a><a class="link" href="#_crud_example_todo">5.1.4. CRUD Example #TODO</a></h4>
<div class="paragraph">
<p>In this example we are going to use a service called <a href="https://www.graph.cool/">graph.cool</a>
to create a complete CRUD using only their GraphQL API.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_connect_todo"><a class="anchor" href="#_connect_todo"></a><a class="link" href="#_connect_todo">5.2. Connect #TODO</a></h3>

</div>
<div class="sect2">
<h3 id="edn_gql"><a class="anchor" href="#edn_gql"></a><a class="link" href="#edn_gql">5.3. EDN&#8594;GraphQL</a></h3>
<div class="paragraph">
<p>Here you can try an interactive convertor. Type your EDN graph query on the left side
and see the GraphQL equivalent been generated on the right.</p>
</div>
<div x-app="edn-graphql-converter"></div>
<link rel="stylesheet" type="text/css" href="assets/css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="assets/css/book.css" />
<script src="assets/js/book/main.js"></script>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2018-02-27 22:49:07 -03
</div>
</div>
</body>
</html>